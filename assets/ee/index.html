<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Desert Chronicles: The Arizona Artifact (Enhanced)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column; /* Allow for messages above/below game */
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #121212;
            font-family: 'Press Start 2P', monospace;
            overflow: hidden;
            color: #FFF;
        }
        
        #gameContainer {
            position: relative;
            width: 640px;
            height: 480px;
            overflow: hidden;
            background-color: #000;
            box-shadow: 0 0 20px rgba(170, 114, 65, 0.7);
            border: 4px solid #8B4513;
            margin-bottom: 10px;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
        }
        
        #uiContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through to canvas if needed */
        }

        #dialogBox {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.9);
            color: #FFF;
            border: 3px solid #8B4513;
            padding: 15px;
            font-size: 12px;
            display: none;
            z-index: 100;
            line-height: 1.5;
        }
        
        #inventory {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #8B4513;
            padding: 5px;
            display: flex;
            z-index: 50;
        }
        
        .invItem {
            width: 32px;
            height: 32px;
            border: 1px solid #666;
            margin: 2px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #FFF;
            background-color: #333;
            cursor: pointer;
        }
        .invItem:hover {
            border-color: #FFF;
        }
        
        #startScreen, #pauseScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            text-align: center;
        }
        
        #startScreen h1, #pauseScreen h1, #gameOverScreen h1 {
            color: #FFAA33;
            font-size: 24px;
            text-shadow: 3px 3px 0 #AA5500;
            margin-bottom: 10px;
        }
        
        #startScreen h2 {
            color: #FF6633;
            font-size: 16px;
            margin-bottom: 30px;
        }
        
        #startScreen p, #pauseScreen p, #gameOverScreen p {
            color: #AAA;
            font-size: 10px;
            max-width: 80%;
            margin-bottom: 20px;
            line-height: 1.5;
        }
        
        #startScreen button, #pauseScreen button, #gameOverScreen button {
            background-color: #8B4513;
            color: #FFF;
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            padding: 10px 20px;
            border: none;
            cursor: pointer;
            margin-top: 10px;
            margin-bottom: 5px;
        }
        #startScreen button:hover, #pauseScreen button:hover, #gameOverScreen button:hover {
            background-color: #AA5500;
        }
        
        #loadingText {
            color: #FFAA33;
            font-size: 12px;
            margin-top: 20px;
        }
        
        .statusBar {
            position: absolute;
            top: 10px;
            height: 15px;
            background-color: #333;
            border: 2px solid #8B4513;
            font-size: 10px;
            line-height: 15px;
            color: white;
            padding-left: 5px;
            z-index: 50;
        }
        #hpBar { right: 120px; width: 100px; }
        #hpFill { width: 100%; height: 100%; background-color: #CC3333; }
        #hydrationBar { right: 10px; width: 100px; }
        #hydrationFill { width: 100%; height: 100%; background-color: #3377CC; }
        
        #mapNameDisplay {
            position: absolute;
            top: 35px; /* Adjusted for new bars */
            right: 10px;
            color: #FFF;
            font-size: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px;
            border: 1px solid #8B4513;
            z-index: 50;
        }

        #questLogDisplay {
            position: absolute;
            bottom: 75px; /* Above dialog box */
            left: 10px;
            color: #FFF;
            font-size: 10px;
            background-color: rgba(0,0,0,0.6);
            padding: 8px;
            border: 1px solid #8B4513;
            z-index: 50;
            max-width: 200px;
            display: none; /* Hidden by default */
        }
        #questLogDisplay h3 {
            margin: 0 0 5px 0;
            font-size: 11px;
            color: #FFAA33;
        }
        #questLogDisplay ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #questLogDisplay li {
            margin-bottom: 3px;
        }
        #clockDisplay {
            position: absolute;
            top: 10px;
            left: 160px; /* Next to inventory */
            color: #FFF;
            font-size: 10px;
            background-color: rgba(0,0,0,0.7);
            padding: 5px 8px;
             border: 1px solid #8B4513;
            z-index: 50;
        }
         #saveNotification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            color: #FFAA33;
            padding: 20px;
            font-size: 14px;
            border: 2px solid #8B4513;
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="640" height="480"></canvas>
        <div id="uiContainer">
            <div id="inventory"></div>
            <div id="hpBar" class="statusBar">HP <div id="hpFill"></div></div>
            <div id="hydrationBar" class="statusBar">H2O <div id="hydrationFill"></div></div>
            <div id="mapNameDisplay">Sonoran Desert</div>
            <div id="clockDisplay">Day 1 - 08:00 AM</div>
            <div id="questLogDisplay">
                <h3>Active Quests:</h3>
                <ul id="questList"></ul>
            </div>
            <div id="dialogBox"></div>
        </div>
        
        <div id="startScreen">
            <h1>DESERT CHRONICLES</h1>
            <h2>The Arizona Artifact</h2>
            <p>The year is 1986. Professor James Walker, retired archaeologist and computer enthusiast, finds himself drawn back into adventure when he discovers an ancient petroglyph map in his Scottsdale home.</p>
            <p>The map hints at a lost artifact hidden somewhere in the Arizona desert - one that may hold the key to understanding the advanced astronomical knowledge of ancient native civilizations.</p>
            <p>Armed with his trusty canteen, pocket computer, and decades of field experience, the Professor embarks on one last expedition...</p>
            <button id="startButton">START ADVENTURE</button>
            <button id="loadButton">LOAD GAME</button>
            <div id="loadingText" style="display: none;">Loading...</div>
        </div>

        <div id="pauseScreen" style="display: none;">
            <h1>PAUSED</h1>
            <button id="resumeButton">RESUME</button>
            <button id="saveButton">SAVE GAME</button>
            <button id="mainMenuButton">MAIN MENU</button>
        </div>

        <div id="gameOverScreen" style="display: none;">
            <h1>GAME OVER</h1>
            <p id="gameOverMessage"></p>
            <button id="restartButton">RESTART</button>
            <button id="gameOverMainMenuButton">MAIN MENU</button>
        </div>
         <div id="saveNotification">Game Saved!</div>
    </div>
    <div id="controlsInfo" style="font-size: 10px; margin-top: 10px; text-align:center; max-width: 640px;">
        Controls: WASD/Arrows - Move | E/Space - Interact | I - Inventory | Q - Quests | P - Pause
    </div>

    <script>
        // --- Core Game Constants ---
        const CANVAS_WIDTH = 640;
        const CANVAS_HEIGHT = 480;
        const TILE_SIZE = 32; // Example, adjust as needed
        const PLAYER_SPEED = 2;
        const HYDRATION_RATE = 0.05; // Amount hydration decreases per game tick (when not paused)
        const HYDRATION_PER_DRINK = 30;
        const GAME_TIME_MULTIPLIER = 60; // 1 real second = 1 game minute

        // --- Game States ---
        const GAME_STATE = {
            START_SCREEN: 'START_SCREEN',
            LOADING: 'LOADING',
            PLAYING: 'PLAYING',
            PAUSED: 'PAUSED',
            DIALOG: 'DIALOG',
            GAME_OVER: 'GAME_OVER',
            INVENTORY_OPEN: 'INVENTORY_OPEN', 
        };

        class SoundManager {
            constructor() {
                this.sounds = {};
                this.music = {};
                this.masterVolume = 1.0;
                this.sfxVolume = 0.7; 
                this.musicVolume = 0.5; 
                this.currentMusic = null; 

                // Music
                this.music.menuTheme = new Audio('music/menu.mp3');
                this.music.firstScenarioTheme = new Audio('sounds/first_scenario.mp3');
                this.music.secondScenarioTheme = new Audio('sounds/second_scenario.mp3');
                this.music.thirdScenarioTheme = new Audio('sounds/third_scenario.mp3');
                this.music.fourthScenarioTheme = new Audio('sounds/fourth_scenario.mp3');


                // Sound Effects
                this.sounds.selectOption = new Audio('sounds/select_options.mp3');
                this.sounds.gameStart = new Audio('sounds/game_start.mp3');
                this.sounds.nextScenario = new Audio('sounds/next_scenario.mp3');
                this.sounds.playerHurt = new Audio('sounds/hurt.mp3');
                this.sounds.getCoin = new Audio('sounds/get_coin.mp3'); 
                this.sounds.getItem = new Audio('sounds/get_item.mp3'); 
                this.sounds.gameOver = new Audio('sounds/game_over.mp3');
                this.sounds.enemyAttack = new Audio('sounds/enemy_attack.mp3'); 
                this.sounds.enemyHit = new Audio('sounds/enemy_hit.mp3'); 
                this.sounds.enemyDie = new Audio('sounds/enemy_die.mp3'); 
                this.sounds.drink = new Audio('sounds/drink.mp3'); 

                Object.values(this.sounds).forEach(sound => sound.volume = this.masterVolume * this.sfxVolume);
                Object.values(this.music).forEach(track => track.volume = this.masterVolume * this.musicVolume);
            }

            playSound(soundName) {
                if (this.sounds[soundName]) {
                    this.sounds[soundName].currentTime = 0;
                    this.sounds[soundName].play().catch(e => console.warn(`Error playing sound ${soundName}:`, e)); 
                } else {
                    console.warn(`Sound not found: ${soundName}`);
                }
            }

            playMusic(musicName, loop = true) {
                if (this.currentMusic && this.music[this.currentMusic]) {
                    this.music[this.currentMusic].pause();
                    this.music[this.currentMusic].currentTime = 0;
                }
                if (this.music[musicName]) {
                    this.music[musicName].loop = loop;
                    this.music[musicName].play().catch(e => console.warn(`Error playing music ${musicName}:`, e)); 
                    this.currentMusic = musicName;
                } else {
                     console.warn(`Music not found: ${musicName}`);
                }
            }

            stopMusic(specificMusicName = null) {
                if (specificMusicName && this.music[specificMusicName]) {
                     this.music[specificMusicName].pause();
                     this.music[specificMusicName].currentTime = 0;
                     if (this.currentMusic === specificMusicName) {
                         this.currentMusic = null;
                     }
                } else if (this.currentMusic && this.music[this.currentMusic]) { 
                    this.music[this.currentMusic].pause();
                    this.music[this.currentMusic].currentTime = 0;
                    this.currentMusic = null;
                }
            }

            pauseCurrentMusic() {
                if (this.currentMusic && this.music[this.currentMusic]) {
                    this.music[this.currentMusic].pause();
                }
            }

            resumeCurrentMusic() {
                if (this.currentMusic && this.music[this.currentMusic]) {
                    this.music[this.currentMusic].play().catch(e => console.warn(`Error resuming music ${this.currentMusic}:`, e));
                }
            }
        }

        class InputHandler {
            constructor(game) {
                this.game = game;
                this.keys = {};
                window.addEventListener('keydown', (e) => this.keys[e.key.toLowerCase()] = true);
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                    this.game.handleKeyUp(e.key.toLowerCase()); 
                });
            }

            isPressed(key) {
                return this.keys[key] || false;
            }
        }

        class UIManager {
            constructor(game) {
                this.game = game;
                this.canvas = document.getElementById('gameCanvas'); 
                this.ctx = this.canvas.getContext('2d');
                this.dialogBox = document.getElementById('dialogBox');
                this.inventoryDiv = document.getElementById('inventory');
                this.hpFill = document.getElementById('hpFill');
                this.hydrationFill = document.getElementById('hydrationFill');
                this.mapNameDisplay = document.getElementById('mapNameDisplay');
                this.clockDisplay = document.getElementById('clockDisplay');
                this.questLogDisplay = document.getElementById('questLogDisplay');
                this.questList = document.getElementById('questList');
                
                this.startScreen = document.getElementById('startScreen');
                this.pauseScreen = document.getElementById('pauseScreen');
                this.gameOverScreen = document.getElementById('gameOverScreen');
                this.loadingText = document.getElementById('loadingText');
                this.saveNotification = document.getElementById('saveNotification');


                document.getElementById('startButton').addEventListener('click', () => {
                    this.game.sound.stopMusic('menuTheme');
                    this.game.sound.playSound('selectOption');
                    this.game.startGame();
                });
                document.getElementById('loadButton').addEventListener('click', () => {
                    this.game.sound.stopMusic('menuTheme');
                    this.game.sound.playSound('selectOption');
                    this.game.loadGame(true);
                });
                document.getElementById('resumeButton').addEventListener('click', () => this.game.togglePause());
                document.getElementById('saveButton').addEventListener('click', () => this.game.saveGame());
                document.getElementById('mainMenuButton').addEventListener('click', () => this.game.goToMainMenu());
                document.getElementById('restartButton').addEventListener('click', () => {
                     this.game.sound.playSound('selectOption');
                     this.game.startGame(true);
                });
                document.getElementById('gameOverMainMenuButton').addEventListener('click', () => {
                    this.game.sound.playSound('selectOption');
                    this.game.goToMainMenu();
                });
            }

            showStartScreen() { this.startScreen.style.display = 'flex'; }
            hideStartScreen() { this.startScreen.style.display = 'none'; }
            showPauseScreen() { this.pauseScreen.style.display = 'flex'; }
            hidePauseScreen() { this.pauseScreen.style.display = 'none'; }
            showGameOverScreen(message) {
                document.getElementById('gameOverMessage').textContent = message;
                this.gameOverScreen.style.display = 'flex';
            }
            hideGameOverScreen() { this.gameOverScreen.style.display = 'none'; }
            
            showLoading() { this.loadingText.style.display = 'block';}
            hideLoading() { this.loadingText.style.display = 'none';}

            updateHealth(current, max) { this.hpFill.style.width = `${(current / max) * 100}%`; }
            updateHydration(current, max) { this.hydrationFill.style.width = `${(current / max) * 100}%`; }
            updateMapName(name) { this.mapNameDisplay.textContent = name; }

            updateClock(gameTimeInSeconds) {
                const day = Math.floor(gameTimeInSeconds / (24 * 60 * 60)) + 1;
                const totalSecondsInDay = gameTimeInSeconds % (24 * 60 * 60);
                const hours = Math.floor(totalSecondsInDay / 3600);
                const minutes = Math.floor((totalSecondsInDay % 3600) / 60);
                const ampm = hours >= 12 ? 'PM' : 'AM';
                const displayHours = hours % 12 === 0 ? 12 : hours % 12;
                this.clockDisplay.textContent = `Day ${day} - ${String(displayHours).padStart(2, '0')}:${String(minutes).padStart(2, '0')} ${ampm}`;
            }
            
            showDialog(text, speaker) {
                this.dialogBox.innerHTML = speaker ? `<strong>${speaker}:</strong> ${text}` : text;
                this.dialogBox.style.display = 'block';
            }
            hideDialog() { this.dialogBox.style.display = 'none'; }

            updateInventoryDisplay(inventory, itemTypes) {
                this.inventoryDiv.innerHTML = '';
                inventory.forEach(itemKey => {
                    const item = itemTypes[itemKey];
                    if (!item) return;
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'invItem';
                    itemDiv.textContent = item.name.charAt(0).toUpperCase();
                    itemDiv.title = `${item.name}: ${item.description}`;
                    itemDiv.addEventListener('click', () => this.game.useItem(itemKey));
                    this.inventoryDiv.appendChild(itemDiv);
                });
            }

            updateQuestLog(quests) {
                if (quests.length === 0) {
                    this.questLogDisplay.style.display = 'none';
                    return;
                }
                this.questLogDisplay.style.display = 'block';
                this.questList.innerHTML = '';
                quests.forEach(quest => {
                    const li = document.createElement('li');
                    li.textContent = quest.description + (quest.completed ? " (Completed)" : "");
                    if(quest.completed) li.style.textDecoration = "line-through";
                    this.questList.appendChild(li);
                });
            }
            
            toggleQuestLog() {
                this.questLogDisplay.style.display = this.questLogDisplay.style.display === 'none' ? 'block' : 'none';
            }

            drawInteractionIndicator(x, y) {
                this.ctx.fillStyle = '#FFFF00';
                this.ctx.beginPath();
                this.ctx.arc(x, y - 35, 5, 0, Math.PI * 2);
                this.ctx.fill();
            }

            showSaveNotification() {
                this.saveNotification.style.display = 'block';
                setTimeout(() => {
                    this.saveNotification.style.display = 'none';
                }, 1500);
            }
        }
        
        class Entity {
            constructor(game, x, y, width, height, type = 'entity') {
                this.game = game;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.animationFrame = 0;
                this.spriteIndex = 0; 
            }

            draw(ctx) { /* Base draw method */ }
            update() { /* Base update method */ }
            
            get centerX() { return this.x + this.width / 2; }
            get centerY() { return this.y + this.height / 2; }
        }

        class Player extends Entity {
            constructor(game, x, y) {
                super(game, x, y, 24, 32, 'player'); 
                this.collisionBox = { xOffset: 4, yOffset: 16, width: 16, height: 16 }; 
                this.speed = PLAYER_SPEED;
                this.direction = 'down';
                this.health = 100;
                this.maxHealth = 100;
                this.hydration = 100;
                this.maxHydration = 100;
                this.inventory = ['canteen', 'compass'];
                this.quests = [ {id: "main_artifact", description: "Find the Arizona Artifact.", completed: false}];
                this.isMoving = false;
            }

            update() {
                this.isMoving = false;
                let nextX = this.x;
                let nextY = this.y;
                let moveX = 0;
                let moveY = 0;

                if (this.game.input.isPressed('w') || this.game.input.isPressed('arrowup')) {
                    moveY = -this.speed; this.direction = 'up'; this.isMoving = true;
                } else if (this.game.input.isPressed('s') || this.game.input.isPressed('arrowdown')) {
                    moveY = this.speed; this.direction = 'down'; this.isMoving = true;
                }
                if (this.game.input.isPressed('a') || this.game.input.isPressed('arrowleft')) {
                    moveX = -this.speed; this.direction = 'left'; this.isMoving = true;
                } else if (this.game.input.isPressed('d') || this.game.input.isPressed('arrowright')) {
                    moveX = this.speed; this.direction = 'right'; this.isMoving = true;
                }
                
                nextX += moveX;
                nextY += moveY;

                if (!this.game.currentMap.checkCollision(nextX + this.collisionBox.xOffset, this.y + this.collisionBox.yOffset, this.collisionBox.width, this.collisionBox.height)) {
                    this.x = nextX;
                }
                if (!this.game.currentMap.checkCollision(this.x + this.collisionBox.xOffset, nextY + this.collisionBox.yOffset, this.collisionBox.width, this.collisionBox.height)) {
                    this.y = nextY;
                }

                this.x = Math.max(0, Math.min(this.x, CANVAS_WIDTH - this.width));
                this.y = Math.max(0, Math.min(this.y, CANVAS_HEIGHT - this.height));

                this.animationFrame++;
                if (this.animationFrame % 8 === 0 && this.isMoving) {
                    this.spriteIndex = (this.spriteIndex + 1) % 4; 
                } else if (!this.isMoving) {
                    this.spriteIndex = 0; 
                }

                this.hydration -= HYDRATION_RATE / 60; 
                if (this.hydration < 0) this.hydration = 0;
                if (this.hydration === 0 && this.animationFrame % 120 === 0) { 
                    this.takeDamage(1, "Dehydration");
                }
                this.game.ui.updateHydration(this.hydration, this.maxHydration);
            }

            draw(ctx) {
                ctx.fillStyle = '#CC3333';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#DDBB99';
                ctx.fillRect(this.x + (this.width/2) - 8, this.y - 14, 16, 16); 
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(this.x + (this.width/2) - 10, this.y - 20, 20, 6);
                const legOffset = this.isMoving ? Math.sin(this.animationFrame * 0.2) * 3 : 0;
                ctx.fillStyle = '#AA2222'; 
                ctx.fillRect(this.x + 4, this.y + this.height - 8 + legOffset, 6, 8);
                ctx.fillRect(this.x + this.width - 10, this.y + this.height - 8 - legOffset, 6, 8);
            }

            interact() {
                const checkRange = 20; 
                let checkX = this.x + this.width / 2;
                let checkY = this.y + this.height / 2;

                switch (this.direction) {
                    case 'up': checkY -= this.height / 2 + checkRange / 2; break;
                    case 'down': checkY += this.height / 2 + checkRange / 2; break;
                    case 'left': checkX -= this.width / 2 + checkRange / 2; break;
                    case 'right': checkX += this.width / 2 + checkRange / 2; break;
                }
                this.game.currentMap.tryInteraction(checkX, checkY, this);
            }

            addItem(itemKey) {
                if (!this.inventory.includes(itemKey)) {
                    this.inventory.push(itemKey);
                    this.game.ui.updateInventoryDisplay(this.inventory, this.game.itemTypes);
                    if (itemKey === 'artifact1' || itemKey === 'final_artifact') { 
                        this.game.sound.playSound('getCoin');
                    } else {
                        this.game.sound.playSound('getItem'); 
                    }
                    return true;
                }
                return false;
            }
            
            hasItem(itemKey) {
                return this.inventory.includes(itemKey);
            }

            takeDamage(amount, source = "Unknown") {
                this.health -= amount;
                if (this.health < 0) this.health = 0;
                this.game.ui.updateHealth(this.health, this.maxHealth);

                const enemySource = source.toLowerCase();
                if (enemySource.includes('coyote') || enemySource.includes('snake')) {
                    this.game.sound.playSound('playerHurt');
                } else if (source !== "Dehydration") { 
                     this.game.sound.playSound('playerHurt'); 
                }
                
                this.game.canvas.style.backgroundColor = '#FF0000';
                setTimeout(() => { this.game.canvas.style.backgroundColor = ''; }, 100);

                if (this.health <= 0) {
                    this.game.gameOver(`Defeated by ${source}.`);
                }
            }

            heal(amount) {
                this.health = Math.min(this.maxHealth, this.health + amount);
                this.game.ui.updateHealth(this.health, this.maxHealth);
            }

            hydrate(amount) {
                this.hydration = Math.min(this.maxHydration, this.hydration + amount);
                this.game.ui.updateHydration(this.hydration, this.maxHydration);
            }
            
            addQuest(quest) { 
                if (!this.quests.find(q => q.id === quest.id)) {
                    this.quests.push(quest);
                    this.game.ui.updateQuestLog(this.quests);
                }
            }
            
            completeQuest(questId) {
                const quest = this.quests.find(q => q.id === questId);
                if (quest && !quest.completed) { // Ensure quest is not already completed
                    quest.completed = true;
                    this.game.ui.updateQuestLog(this.quests);
                    this.game.ui.showDialog(`Quest Completed: ${quest.description}`, "System");
                    // Potentially trigger game win state if it's the main artifact quest
                    if (quest.id === "main_artifact") {
                        this.game.ui.showDialog("Congratulations! You've found the Arizona Artifact and uncovered its secrets!", "Victory!");
                        // Could set a game state GAME_STATE.WIN or similar
                    }
                }
            }
        }
        
        class NPC extends Entity {
            constructor(game, x, y, name, spriteKey, dialog) {
                super(game, x, y, 24, 32, 'npc'); 
                this.name = name;
                this.spriteKey = spriteKey; 
                this.dialog = dialog; 
                this.isInteractable = true;
            }

            draw(ctx) {
                ctx.fillStyle = '#5577AA'; 
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#DDBB99'; 
                ctx.fillRect(this.x + 4, this.y - 14, 16, 16);
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '8px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, this.x + this.width / 2, this.y - 20);
                ctx.textAlign = 'left'; 
            }

            onInteract(player) {
                let currentDialog = this.dialog;
                if (typeof this.dialog === 'function') {
                    currentDialog = this.dialog(player, this.game);
                } else if (Array.isArray(this.dialog)) {
                    if (this.dialogIndex === undefined || this.dialogIndex >= this.dialog.length -1 ) this.dialogIndex = 0;
                    else this.dialogIndex++;
                    currentDialog = this.dialog[this.dialogIndex];
                }
                this.game.ui.showDialog(currentDialog, this.name);
                this.game.setGameState(GAME_STATE.DIALOG);
            }
        }
        
        class Enemy extends Entity {
            constructor(game, x, y, enemyTypeData) {
                super(game, x, y, enemyTypeData.width, enemyTypeData.height, 'enemy');
                this.enemyType = enemyTypeData; // This should be a copy of the base type data
                this.health = enemyTypeData.health;
                this.speed = enemyTypeData.speed;
                this.damage = enemyTypeData.damage;
                this.aggroRange = 150;
                this.attackRange = 20; 
                this.attackCooldown = 120; // Frames
                this.currentAttackCooldown = 0;
            }

            update() {
                if (this.currentAttackCooldown > 0) this.currentAttackCooldown--;

                const player = this.game.player;
                const distX = player.centerX - this.centerX;
                const distY = player.centerY - this.centerY;
                const distanceToPlayer = Math.sqrt(distX * distX + distY * distY);

                if (distanceToPlayer < this.aggroRange) {
                    if (distanceToPlayer > this.attackRange) {
                        this.x += (distX / distanceToPlayer) * this.speed;
                        this.y += (distY / distanceToPlayer) * this.speed;
                    } else if (this.currentAttackCooldown === 0) {
                        player.takeDamage(this.damage, this.enemyType.name); 
                        this.currentAttackCooldown = this.attackCooldown;
                        this.game.sound.playSound('enemyAttack'); 
                        this.x -= (distX / distanceToPlayer) * 10;
                        this.y -= (distY / distanceToPlayer) * 10;
                    }
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.enemyType.color || '#FF0000'; 
                ctx.fillRect(this.x, this.y, this.width, this.height);
                if (this.health < this.enemyType.health) {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x, this.y - 8, this.width, 4);
                    ctx.fillStyle = 'green';
                    ctx.fillRect(this.x, this.y - 8, this.width * (this.health / this.enemyType.health) , 4);
                }
            }

            takeDamage(amount) {
                this.health -= amount;
                this.game.sound.playSound('enemyHit');
                if (this.health <= 0) {
                    this.game.currentMap.removeEnemy(this);
                    this.game.sound.playSound('enemyDie');
                }
            }
        }

        class InteractiveObject extends Entity {
            constructor(game, x, y, objData) {
                super(game, x, y, objData.width, objData.height, objData.type);
                // It's crucial that objData is a unique copy for this instance,
                // especially for properties like 'opened' or 'isNowPortal'
                this.objData = JSON.parse(JSON.stringify(objData)); // Deep copy objData
                this.isInteractable = this.objData.interactive || this.objData.portal || this.objData.portalOnInteract;
            }

            draw(ctx) {
                ctx.fillStyle = this.objData.color || '#888888'; 
                if (this.type === 'cactus') {
                    ctx.fillStyle = '#2D7D40';
                    ctx.fillRect(this.x + 8, this.y, 16, 32);
                    ctx.fillRect(this.x, this.y + 8, 32, 16);
                } else if (this.type === 'rock') {
                    ctx.fillStyle = '#7D7064';
                    ctx.beginPath();
                    ctx.arc(this.x + 16, this.y + 16, 16, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'chest') {
                    ctx.fillStyle = this.objData.opened ? '#654321' : '#8B4513'; 
                    ctx.fillRect(this.x, this.y + 10, this.width, this.height - 10);
                    ctx.fillStyle = '#DAA520'; 
                    ctx.fillRect(this.x + this.width/2 - 2, this.y + this.height/2, 4, 10); 
                } else if (this.type === 'sign' || this.type === 'interactive_point') {
                    ctx.fillStyle = '#8B4513'; 
                    ctx.fillRect(this.x + this.width/2 - 4, this.y + this.height/2, 8, this.height/2);
                    ctx.fillStyle = '#DAA520'; 
                    ctx.fillRect(this.x, this.y, this.width, this.height/2);
                } else if (this.type === 'water_source') {
                    ctx.fillStyle = '#3377CC'; 
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.fillStyle = '#66AADD'; 
                    ctx.fillRect(this.x + 4, this.y + 4, this.width - 8, this.height - 8);
                } else if (this.type === 'doorway' || (this.type === 'secret_panel' && this.objData.isNowPortal)) {
                    ctx.fillStyle = '#555555'; // Doorway color
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                     if (this.objData.text) { // Draw text on doorway if available (simple implementation)
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = '8px "Press Start 2P"';
                        ctx.textAlign = 'center';
                        ctx.fillText(this.objData.text.substring(0,10)+"...", this.x + this.width/2, this.y - 5);
                        ctx.textAlign = 'left';
                    }
                } else if (this.type === 'computer_terminal') {
                    ctx.fillStyle = '#222'; ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.fillStyle = '#3F3'; ctx.fillRect(this.x+2, this.y+2, this.width-4, this.height-4); // Screen
                } else if (this.type === 'lab_bench') {
                    ctx.fillStyle = '#777'; ctx.fillRect(this.x, this.y, this.width, this.height);
                } else if (this.type === 'server_rack') {
                    ctx.fillStyle = '#333'; ctx.fillRect(this.x, this.y, this.width, this.height);
                    for(let i=0; i<4; i++) { ctx.fillStyle = i%2==0 ? '#0F0':'#0A0'; ctx.fillRect(this.x+4, this.y+4 + i*8, 8, 4); } // Blinky lights
                } else if (this.type === 'secret_panel' && !this.objData.isNowPortal) {
                     ctx.fillStyle = '#6B5B4B'; // Wall color slightly different
                     ctx.fillRect(this.x, this.y, this.width, this.height);
                } else if (this.type === 'pedestal') {
                    ctx.fillStyle = '#8888AA'; ctx.fillRect(this.x, this.y, this.width, this.height);
                    if (!this.objData.opened) { // Draw artifact on pedestal if not taken
                         ctx.fillStyle = '#FFD700'; // Gold color for artifact
                         ctx.fillRect(this.x + this.width/4, this.y + this.height/4, this.width/2, this.height/2);
                    }
                }
                 else {
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }

            onInteract(player) {
                // Handle objects that become portals after interaction + dialog
                if (this.objData.portalOnInteract && this.objData.toMap && !this.objData.isNowPortal) {
                    if(this.objData.interactionText) {
                        this.game.ui.showDialog(this.objData.interactionText, (this.objData.name || this.type).toUpperCase());
                        this.game.setGameState(GAME_STATE.DIALOG);
                        // Set up a pending portal to be actioned when dialog is closed
                        this.game.pendingPortal = { mapName: this.objData.toMap, toX: this.objData.toX, toY: this.objData.toY };
                        // Optionally, change the object's state so it doesn't re-trigger this specific logic
                        this.objData.isNowPortal = true; // Mark that it's "revealed"
                        this.objData.text = "The passage is open."; // Update text for future (though it might portal away)
                    } else {
                        // No interaction text, portal immediately
                        this.game.changeMap(this.objData.toMap, this.objData.toX, this.objData.toY);
                    }
                    return;
                }

                // Standard portal logic (e.g., for doorways or revealed secret panels)
                if (this.objData.portal && this.objData.toMap) {
                    this.game.changeMap(this.objData.toMap, this.objData.toX, this.objData.toY);
                    return;
                }

                // Chests / Item containers (like pedestal)
                if ((this.type === 'chest' || this.type === 'pedestal') && this.objData.contains && !this.objData.opened) {
                    if (player.addItem(this.objData.contains)) {
                        this.game.ui.showDialog(this.objData.text || `You found a ${this.game.itemTypes[this.objData.contains].name}!`, this.type.toUpperCase());
                        this.objData.opened = true; 
                        if (this.objData.questComplete) { // If finding item completes a quest
                            player.completeQuest(this.objData.questComplete);
                        }
                    } else {
                         this.game.ui.showDialog("The container is empty or you already have this item.", this.type.toUpperCase());
                    }
                     this.game.setGameState(GAME_STATE.DIALOG);
                     return;
                }
                
                // General text interactions
                if (this.objData.text && !this.objData.opened) { // Avoid re-showing text for already "used" pedestal
                    this.game.ui.showDialog(this.objData.text, (this.objData.name || this.type).toUpperCase());
                    this.game.setGameState(GAME_STATE.DIALOG);
                }

                // Water source
                if (this.type === 'water_source') {
                    if (player.hydration < player.maxHydration) {
                        player.hydrate(player.maxHydration); 
                        this.game.ui.showDialog("You refill your canteen and take a long drink. You feel refreshed.", "Water Source");
                        this.game.sound.playSound('drink');
                    } else {
                        this.game.ui.showDialog("Your canteen is already full.", "Water Source");
                    }
                    this.game.setGameState(GAME_STATE.DIALOG);
                    return;
                }

                // Quest triggers
                if (this.objData.questTrigger) { 
                    player.addQuest(this.objData.questTrigger);
                     this.game.ui.showDialog(this.objData.questTrigger.startText || `New Quest: ${this.objData.questTrigger.description}`, "INFO");
                     this.game.setGameState(GAME_STATE.DIALOG);
                     // Make sure quest trigger is a one-time event if desired
                     delete this.objData.questTrigger; 
                     return;
                }

                // Quest completion requiring an item
                 if (this.objData.requiredItem && this.objData.questComplete) {
                    if (player.hasItem(this.objData.requiredItem)) {
                        player.completeQuest(this.objData.questComplete);
                        if(this.objData.rewardText) this.game.ui.showDialog(this.objData.rewardText, "System");
                        this.isInteractable = false; 
                    } else {
                        this.game.ui.showDialog(this.objData.needItemText || "You seem to be missing something...", "System");
                    }
                    this.game.setGameState(GAME_STATE.DIALOG);
                    return;
                }
            }
        }
        
        class GameMap {
            constructor(game, mapData) {
                this.game = game;
                this.name = mapData.name;
                this.background = mapData.background;
                this.objects = [];
                this.npcs = [];
                this.enemies = [];
                
                this.loadEntities(mapData);
            }

            loadEntities(mapData) {
                this.objects = [];
                this.npcs = [];
                this.enemies = [];

                mapData.objects.forEach(objData => {
                    const baseObjectType = this.game.objectTypes[objData.type] || {};
                    // Create a unique instance of object data by merging base type and map-specific data
                    const instanceData = JSON.parse(JSON.stringify({ ...baseObjectType, ...objData }));
                    this.objects.push(new InteractiveObject(this.game, instanceData.x, instanceData.y, instanceData));
                });
                (mapData.npcs || []).forEach(npcData => {
                    this.npcs.push(new NPC(this.game, npcData.x, npcData.y, npcData.name, npcData.sprite, npcData.dialog));
                });
                (mapData.enemies || []).forEach(enemyData => {
                    const baseEnemyType = {...this.game.enemyTypes[enemyData.type]}; 
                    this.enemies.push(new Enemy(this.game, enemyData.x, enemyData.y, {...baseEnemyType, name: enemyData.type})); // Pass a copy
                });
            }

            update() {
                if (this.game.gameState !== GAME_STATE.PLAYING) return;
                this.npcs.forEach(npc => npc.update());
                // Ensure enemies array is not modified during iteration if an enemy is removed
                [...this.enemies].forEach(enemy => enemy.update());
            }

            draw(ctx) {
                ctx.fillStyle = this.background;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                if (!this.game.dayTime) {
                    ctx.fillStyle = 'rgba(0, 0, 30, 0.65)'; 
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                }

                const allDrawableEntities = [...this.objects, ...this.npcs, ...this.enemies, this.game.player];
                allDrawableEntities.sort((a, b) => (a.y + a.height) - (b.y + b.height));
                
                allDrawableEntities.forEach(entity => {
                    if (entity) entity.draw(ctx); // Add check for entity existence
                });
            }

            checkCollision(x, y, width, height) {
                if (x < 0 || x + width > CANVAS_WIDTH || y < 0 || y + height > CANVAS_HEIGHT) {
                    return true;
                }
                for (const obj of this.objects) {
                    if (obj.objData.solid && 
                        x < obj.x + obj.width && x + width > obj.x &&
                        y < obj.y + obj.height && y + height > obj.y) {
                        return true;
                    }
                }
                return false;
            }

            tryInteraction(checkX, checkY, player) {
                let interactionTarget = null;
                let minDistance = Infinity;

                const checkInteraction = (entity) => {
                    if (!entity.isInteractable) return;
                    const dist = Math.sqrt(Math.pow(entity.centerX - checkX, 2) + Math.pow(entity.centerY - checkY, 2));
                    if (dist < (entity.width + entity.height) / 2 + 10 && dist < minDistance) { 
                        minDistance = dist;
                        interactionTarget = entity;
                    }
                };
                // Iterate over copies in case onInteract modifies the arrays (e.g. an object becomes non-interactable)
                [...this.objects, ...this.npcs].forEach(checkInteraction);


                if (interactionTarget) {
                    this.game.interactionTarget = interactionTarget; 
                    interactionTarget.onInteract(player);
                } else {
                    this.game.interactionTarget = null;
                }
            }
            
            removeEnemy(enemyInstance) {
                this.enemies = this.enemies.filter(e => e !== enemyInstance);
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameState = GAME_STATE.START_SCREEN;
                
                this.sound = new SoundManager(); 
                this.ui = new UIManager(this);
                this.input = new InputHandler(this);

                this.player = null;
                this.currentMap = null;
                this.interactionTarget = null; 
                this.pendingPortal = null; // For handling portals after dialog

                this.gameTime = 8 * 3600; 
                this.dayTime = true;
                this.lastFrameTime = 0;
                this.timeToNextHydrationTick = 1; 

                this.defineGameData(); 

                this.ui.showStartScreen();
                this.sound.playMusic('menuTheme');
            }

            defineGameData() {
                this.objectTypes = { 
                    cactus: { width: 32, height: 48, solid: true, color: '#2D7D40' },
                    rock: { width: 32, height: 32, solid: true, color: '#7D7064' },
                    chest: { width: 32, height: 32, solid: true, interactive: true, color: '#8B4513', opened: false }, 
                    sign: { width: 32, height: 32, solid: false, interactive: true, color: '#DAA520' }, // Signs usually not solid
                    interactive_point: {width: 32, height: 32, solid: false, interactive: true, color: '#DAA520'}, // Similar to sign
                    petroglyph: { width: 48, height: 48, solid: false, interactive: true, color: '#AA6633' },
                    doorway: { width: 48, height: 16, solid: false, portal: true, color: '#555555', interactive: true }, // Doorways are interactive portals
                    water_source: { width: 32, height: 32, solid: false, interactive: true, color: '#3377CC'},
                    computer_terminal: { name: "Computer", width: 32, height: 32, solid: true, interactive: true, color: '#222222'},
                    lab_bench: { name: "Lab Bench", width: 96, height: 32, solid: true, interactive: false, color: '#777777'},
                    server_rack: { name: "Server Rack", width: 48, height: 128, solid: true, interactive: true, color: '#333333', text: "Humming servers... data unknown."},
                    secret_panel: { name: "Loose Panel", width: 32, height: 48, solid:true, interactive: true, color: '#6B5B4B'}, // Part of wall initially
                    pedestal: { name: "Pedestal", width: 32, height: 32, solid: true, interactive: true, color: '#8888AA', opened: false}
                };
                this.enemyTypes = {
                    scorpion: { name: 'Scorpion', width: 24, height: 24, damage: 5, speed: 0.8, health: 30, color: '#663300' },
                    snake: { name: 'Snake', width: 32, height: 16, damage: 8, speed: 1.2, health: 20, color: '#AA7722' },
                    coyote: { name: 'Coyote', width: 40, height: 24, damage: 10, speed: 1.5, health: 50, color: '#AA8855' }
                };
                this.itemTypes = {
                    canteen: { name: 'Canteen', description: 'Keeps you hydrated. Refill at water sources.', useFunc: (game) => {
                        if (game.player.hydration < game.player.maxHydration) {
                            game.player.hydrate(HYDRATION_PER_DRINK);
                            game.ui.showDialog("You take a drink of water.", "Canteen");
                            game.sound.playSound('drink');
                        } else {
                             game.ui.showDialog("You're not thirsty right now.", "Canteen");
                        }
                        game.setGameState(GAME_STATE.DIALOG);
                    }},
                    compass: { name: 'Compass', description: 'Helps you navigate (shows direction).' },
                    journal: { name: 'Journal', description: 'Contains research notes and quests.', useFunc: (game) => {
                        game.ui.toggleQuestLog(); 
                    }},
                    artifact1: { name: 'Stone Tablet', description: 'Part of an ancient artifact set.' },
                    final_artifact: { name: 'Arizona Artifact', description: 'The legendary treasure!'},
                    flashlight: { name: 'Flashlight', description: 'Illuminates dark areas.' },
                    diskette: { name: 'Floppy Disk', description: '5.25" floppy with mysterious data.' }
                };
                 this.maps = {
                    desert: { // Sonoran Desert Outskirts
                        name: 'Sonoran Desert Outskirts', background: '#E2C9A1',
                        objects: [
                            { type: 'cactus', x: 100, y: 100 }, { type: 'cactus', x: 400, y: 150 },
                            { type: 'rock', x: 250, y: 200 }, { type: 'rock', x: 550, y: 50},
                            { type: 'sign', x: 150, y: 240, text: "Caution: Desert conditions ahead. Stay hydrated!" },
                            { type: 'water_source', x: 50, y: 300},
                            { type: 'petroglyph', x: 500, y: 200, text: "Ancient symbols depict stars and a mountain range...",
                                questTrigger: {id: "petro_observe", description: "Investigate the petroglyphs.", startText: "These markings seem important..."} },
                            { type: 'doorway', x: CANVAS_WIDTH - 48, y: 232, toMap: 'canyon', toX: 50, toY: 240, text: "To Canyon"}
                        ],
                        npcs: [ { name: 'Ranger Rick', x: 200, y: 300, dialog: ["Howdy, Professor! Dehydration is no joke.", "Strange lights in the sky lately...", "Probably military tests... or swamp gas."] } ],
                        enemies: [ { type: 'scorpion', x: 300, y: 400 }, { type: 'snake', x: 450, y: 100 } ]
                    },
                    canyon: { // Red Rock Canyon
                        name: 'Red Rock Canyon', background: '#BC6C25',
                        objects: [
                            { type: 'rock', x: 100, y: 100 }, { type: 'rock', x: 150, y: 90 },
                            { type: 'chest', x: 400, y: 200, contains: 'artifact1', text: "You found an ancient stone tablet!" },
                            { type: 'doorway', x: 0, y: 232, toMap: 'desert', toX: CANVAS_WIDTH - 70, toY: 240, text:"To Desert"},
                            { type: 'doorway', x: CANVAS_WIDTH - 48, y: 100, toMap: 'camelback', toX: 50, toY: 100, text:"To Mt."}
                        ],
                        npcs: [ { name: 'Old Hermit', x: 250, y: 150, dialog: (player, game) => {
                                if (player.hasItem('artifact1')) { player.completeQuest("petro_observe"); return "Ah, the tablet! It speaks of stars... you are on the right path."; }
                                return "This canyon whispers secrets... Got any jerky?";
                            }}],
                        enemies: [ { type: 'coyote', x: 350, y: 100 }, { type: 'snake', x: 150, y: 300 } ]
                    },
                    camelback: { // Camelback Mountain Trail
                        name: 'Camelback Mountain Trail', background: '#A0B084',
                        objects: [
                            { type: 'sign', x: 50, y: 400, text: "Echo Canyon Trailhead" },
                            { type: 'rock', x: 150, y: 350 }, { type: 'rock', x: 200, y: 330 }, { type: 'cactus', x: 400, y: 100},
                            { type: 'interactive_point', x: 320, y: 50, text: "Scenic Overlook: A breathtaking view of Scottsdale and Phoenix." },
                            { type: 'doorway', x: 0, y: 100, toMap: 'canyon', toX: CANVAS_WIDTH - 70, toY: 100, text:"To Canyon"},
                            { type: 'doorway', x: CANVAS_WIDTH-48, y: 200, toMap: 'asu_lab', toX: 50, toY: 240, text:"Tunnel"}
                        ],
                        npcs: [ { name: 'Tired Hiker', x: 450, y: 280, dialog: ["Almost... at the top... Need water!", "Watch out for loose rocks."]} ],
                        enemies: [ { type: 'snake', x: 200, y: 150 }, {type: 'coyote', x: 500, y: 350} ]
                    },
                    asu_lab: { // ASU Engineering Lab
                        name: 'ASU Engineering Lab', background: '#4A4A52',
                        objects: [
                            { type: 'computer_terminal', x: 100, y: 100, text: "System Offline. Requires Admin Access." },
                            { type: 'lab_bench', x: 200, y: 150, width: 96, height: 32},
                            { type: 'server_rack', x: 500, y: 80, width: 48, height: 128},
                            { type: 'secret_panel', x: 300, y: 400, width:32, height:48, 
                                portalOnInteract: true, toMap: 'artifact_chamber', toX: CANVAS_WIDTH/2 - 16, toY: CANVAS_HEIGHT - 80, 
                                interactionText: "You push the panel, it slides open revealing a dark passage!" },
                            { type: 'doorway', x: 0, y: 232, toMap: 'camelback', toX: CANVAS_WIDTH - 70, toY: 200, text:"Exit"}
                        ],
                        npcs: [ {name: "Grad Student", x: 400, y: 300, dialog: ["Working on my thesis... don't mind the mess.", "Heard whispers of a hidden chamber somewhere on campus."]}],
                        enemies: [] // No enemies in the lab for now
                    },
                    artifact_chamber: {
                        name: 'Hidden Artifact Chamber', background: '#301020',
                        objects: [
                            { type: 'pedestal', x: CANVAS_WIDTH/2 - 16, y: CANVAS_HEIGHT/2 - 16, contains: 'final_artifact', text: "The Arizona Artifact rests here!", questComplete: "main_artifact" },
                            { type: 'doorway', x: CANVAS_WIDTH/2 - 24, y: CANVAS_HEIGHT - 48, toMap: 'asu_lab', toX: 300, toY: 380, text: "Return to Lab"}
                        ],
                        npcs: [], enemies: []
                    }
                };
            }
            
            setGameState(newState) {
                const oldState = this.gameState;
                this.gameState = newState;
                
                this.ui.hideDialog(); this.ui.hidePauseScreen(); this.ui.hideStartScreen(); this.ui.hideGameOverScreen();

                switch(newState) {
                    case GAME_STATE.START_SCREEN: 
                        this.ui.showStartScreen(); 
                        this.sound.playMusic('menuTheme');
                        break;
                    case GAME_STATE.PLAYING: 
                        if (oldState === GAME_STATE.PAUSED) {
                            this.sound.resumeCurrentMusic();
                        } 
                        break; 
                    case GAME_STATE.PAUSED: 
                        this.ui.showPauseScreen(); 
                        this.sound.pauseCurrentMusic(); 
                        break;
                    case GAME_STATE.DIALOG: break;
                    case GAME_STATE.GAME_OVER: 
                        this.sound.stopMusic(); 
                        this.sound.playSound('gameOver'); 
                        break;
                }
            }

            startGame(isRestart = false) {
                this.ui.hideStartScreen();
                this.ui.showLoading();
                
                setTimeout(() => {
                    this.player = new Player(this, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                    this.gameTime = 8 * 3600; 
                    this.defineGameData(); 
                    this.currentMap = null; // Explicitly set to null before first changeMap for initial load logic
                    this.changeMap('desert', this.player.x, this.player.y); 
                    
                    this.ui.updateHealth(this.player.health, this.player.maxHealth);
                    this.ui.updateHydration(this.player.hydration, this.player.maxHydration);
                    this.ui.updateInventoryDisplay(this.player.inventory, this.itemTypes);
                    this.ui.updateQuestLog(this.player.quests);
                    
                    this.setGameState(GAME_STATE.PLAYING); 
                    this.ui.hideLoading();
                    if (!isRestart || this.lastFrameTime === 0) { 
                         this.gameLoop(0); 
                    }
                }, 500);
            }
            
            goToMainMenu() {
                this.sound.stopMusic(); 
                this.setGameState(GAME_STATE.START_SCREEN); 
            }

            changeMap(mapName, playerX, playerY) {
                const isInitialLoad = !this.currentMap; 

                this.sound.stopMusic(); 

                if (!isInitialLoad) {
                    this.sound.playSound('nextScenario');
                }

                if (this.maps[mapName]) {
                    const mapData = this.maps[mapName];
                    const freshMapData = JSON.parse(JSON.stringify(mapData)); 
                    this.currentMap = new GameMap(this, freshMapData); // Assign to this.currentMap BEFORE checking its name
                    
                    if (this.player) { 
                        this.player.x = playerX;
                        this.player.y = playerY;
                    }
                    this.ui.updateMapName(this.currentMap.name); // Now this.currentMap is defined

                    // Play new map's music
                    // Add a slight delay for nextScenario sound to play, if it's not the initial load
                    const musicDelay = isInitialLoad ? 0 : (this.sound.sounds.nextScenario.duration && isFinite(this.sound.sounds.nextScenario.duration) ? this.sound.sounds.nextScenario.duration * 1000 : 200);

                    setTimeout(() => {
                        if (this.gameState !== GAME_STATE.PLAYING && this.gameState !== GAME_STATE.DIALOG) return; // Only play if in relevant state
                        if (!this.currentMap || this.currentMap.name !== mapData.name) return; // Ensure still on the target map

                        if (mapName === 'desert') {
                            if (isInitialLoad) { 
                                this.sound.playSound('gameStart');
                                const gameStartDuration = this.sound.sounds.gameStart.duration;
                                setTimeout(() => {
                                    if (this.gameState === GAME_STATE.PLAYING && this.currentMap && this.currentMap.name === 'Sonoran Desert Outskirts') {
                                        this.sound.playMusic('firstScenarioTheme', true);
                                    }
                                }, gameStartDuration && isFinite(gameStartDuration) ? gameStartDuration * 1000 : 500);
                            } else {
                                this.sound.playMusic('firstScenarioTheme', true);
                            }
                        } else if (mapName === 'canyon') {
                            this.sound.playMusic('secondScenarioTheme', true);
                        } else if (mapName === 'camelback') {
                            this.sound.playMusic('thirdScenarioTheme', true);
                        } else if (mapName === 'asu_lab') {
                            this.sound.playMusic('fourthScenarioTheme', true);
                        } else if (mapName === 'artifact_chamber') {
                            this.sound.playSound('getCoin'); // Discovery sound
                        }
                    }, musicDelay);

                } else {
                    console.error(`Map ${mapName} not found!`);
                }
            }

            gameLoop(timestamp) {
                const deltaTime = (timestamp - this.lastFrameTime) / 1000; 
                this.lastFrameTime = timestamp;

                if (this.gameState === GAME_STATE.PLAYING) {
                    this.update(deltaTime);
                }
                this.draw();
                
                requestAnimationFrame((ts) => this.gameLoop(ts));
            }

            update(deltaTime) {
                if (!this.player || !this.currentMap) return;

                this.player.update();
                this.currentMap.update();
                this.interactionTarget = null; 

                this.gameTime += deltaTime * GAME_TIME_MULTIPLIER;
                const currentHour = Math.floor((this.gameTime % (24 * 3600)) / 3600);
                this.dayTime = currentHour >= 6 && currentHour < 20; 
                this.ui.updateClock(this.gameTime);

                let checkX = this.player.x + this.player.width / 2;
                let checkY = this.player.y + this.player.height / 2;
                const checkRange = 20;
                 switch (this.player.direction) {
                    case 'up': checkY -= this.player.height / 2 + checkRange / 2; break;
                    case 'down': checkY += this.player.height / 2 + checkRange / 2; break;
                    case 'left': checkX -= this.player.width / 2 + checkRange / 2; break;
                    case 'right': checkX += this.player.width / 2 + checkRange / 2; break;
                }
                const potentialTargets = [...this.currentMap.objects, ...this.currentMap.npcs];
                for (const entity of potentialTargets) {
                    if (entity.isInteractable && 
                        Math.abs(entity.centerX - checkX) < (entity.width/2 + 10) && 
                        Math.abs(entity.centerY - checkY) < (entity.height/2 + 10)) {
                        this.interactionTarget = entity;
                        break;
                    }
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); 
                if (this.gameState === GAME_STATE.PLAYING || this.gameState === GAME_STATE.DIALOG || this.gameState === GAME_STATE.PAUSED) {
                    if (this.currentMap && this.player) { 
                        this.currentMap.draw(this.ctx);
                    }
                    if (this.interactionTarget && this.gameState === GAME_STATE.PLAYING) {
                        this.ui.drawInteractionIndicator(this.interactionTarget.centerX, this.interactionTarget.y);
                    }
                }
            }
            
            handleKeyUp(key) {
                if (this.gameState === GAME_STATE.PLAYING) {
                    if (key === 'e' || key === ' ') {
                        this.player.interact();
                    } else if (key === 'p') {
                        this.togglePause();
                    } else if (key === 'i') {
                        this.ui.showDialog("Inventory: " + this.player.inventory.map(itemKey => this.itemTypes[itemKey].name).join(', '), "System");
                        this.setGameState(GAME_STATE.DIALOG);
                    } else if (key === 'q') {
                         this.ui.toggleQuestLog();
                    }
                } else if (this.gameState === GAME_STATE.DIALOG) {
                    if (key === 'e' || key === ' ' || key === 'enter') {
                        this.ui.hideDialog();
                        if (this.pendingPortal) {
                            this.changeMap(this.pendingPortal.mapName, this.pendingPortal.toX, this.pendingPortal.toY);
                            this.pendingPortal = null; // Clear it after use
                        } else {
                           this.setGameState(GAME_STATE.PLAYING); 
                        }
                    }
                } else if (this.gameState === GAME_STATE.PAUSED) {
                     if (key === 'p') this.togglePause();
                } 
            }

            togglePause() {
                if (this.gameState === GAME_STATE.PLAYING) {
                    this.setGameState(GAME_STATE.PAUSED);
                } else if (this.gameState === GAME_STATE.PAUSED) {
                    this.setGameState(GAME_STATE.PLAYING);
                }
            }

            useItem(itemKey) {
                if (this.gameState !== GAME_STATE.PLAYING && this.gameState !== GAME_STATE.DIALOG) return;

                const item = this.itemTypes[itemKey];
                if (item && item.useFunc) {
                    item.useFunc(this); 
                } else if (item) {
                    this.ui.showDialog(`${item.name}: ${item.description}`, "Item");
                    this.setGameState(GAME_STATE.DIALOG);
                }
            }

            saveGame() {
                if (!this.player || !this.currentMap) {
                    console.warn("Cannot save: game not fully initialized.");
                    this.ui.showDialog("Cannot save game state yet.", "System")
                    return;
                }
                const savableObjects = this.currentMap.objects.map(obj => {
                    return { 
                        type: obj.type, 
                        x: obj.x, 
                        y: obj.y, 
                        opened: obj.objData.opened, // For chests/pedestals
                        isNowPortal: obj.objData.isNowPortal // For secret panels
                        // Add other relevant state from obj.objData
                    };
                });

                const saveData = {
                    player: {
                        x: this.player.x, y: this.player.y,
                        health: this.player.health, hydration: this.player.hydration,
                        inventory: this.player.inventory, quests: this.player.quests,
                        direction: this.player.direction,
                    },
                    currentMapName: this.currentMap.name,
                    gameTime: this.gameTime,
                    mapObjectsState: savableObjects 
                };
                try {
                    localStorage.setItem('desertChroniclesSave', JSON.stringify(saveData));
                    console.log('Game Saved:', saveData);
                    this.ui.showSaveNotification();
                    if(this.gameState === GAME_STATE.PAUSED) this.ui.showDialog("Game Saved!", "System");

                } catch (e) {
                    console.error('Error saving game:', e);
                     if(this.gameState === GAME_STATE.PAUSED) this.ui.showDialog("Error saving game.", "System");
                }
            }

            loadGame(fromStartScreen = false) {
                if (fromStartScreen) {
                    this.ui.hideStartScreen();
                    this.ui.showLoading();
                }
                try {
                    const savedDataJSON = localStorage.getItem('desertChroniclesSave');
                    if (!savedDataJSON) {
                        console.warn('No save data found.');
                         if (fromStartScreen) {
                            this.ui.hideLoading(); this.ui.showStartScreen(); 
                            alert("No save data found!"); 
                            this.sound.playMusic('menuTheme'); 
                         }
                        return false;
                    }
                    const saveData = JSON.parse(savedDataJSON);

                    if (!this.player) {
                        this.player = new Player(this, saveData.player.x, saveData.player.y);
                    } else { // If player exists (e.g. loading from pause menu after starting new game)
                        this.player.x = saveData.player.x; this.player.y = saveData.player.y;
                    }


                    this.player.health = saveData.player.health;
                    this.player.hydration = saveData.player.hydration;
                    this.player.inventory = saveData.player.inventory;
                    this.player.quests = saveData.player.quests || [{id: "main_artifact", description: "Find the Arizona Artifact.", completed: false}]; 
                    this.player.direction = saveData.player.direction;
                    this.gameTime = saveData.gameTime;
                    
                    this.currentMap = null; // Ensure it's reset before changeMap logic
                    this.changeMap(saveData.currentMapName, this.player.x, this.player.y);
                    
                    // Restore map object states AFTER currentMap is loaded by changeMap
                    if (saveData.mapObjectsState && this.currentMap) {
                        this.currentMap.objects.forEach(gameObj => {
                            const savedObj = saveData.mapObjectsState.find(s => s.x === gameObj.x && s.y === gameObj.y && s.type === gameObj.type);
                            if (savedObj) {
                                if (savedObj.opened !== undefined) gameObj.objData.opened = savedObj.opened;
                                if (savedObj.isNowPortal !== undefined) gameObj.objData.isNowPortal = savedObj.isNowPortal;
                                // Restore other states if needed
                            }
                        });
                    }


                    this.ui.updateHealth(this.player.health, this.player.maxHealth);
                    this.ui.updateHydration(this.player.hydration, this.player.maxHydration);
                    this.ui.updateInventoryDisplay(this.player.inventory, this.itemTypes);
                    this.ui.updateQuestLog(this.player.quests);
                    
                    this.setGameState(GAME_STATE.PLAYING);
                    console.log('Game Loaded.');
                    if (fromStartScreen) {
                        this.ui.hideLoading();
                        if (this.lastFrameTime === 0) this.gameLoop(0); 
                    }
                    return true;

                } catch (e) {
                    console.error('Error loading game:', e);
                    if (fromStartScreen) {
                        this.ui.hideLoading(); this.ui.showStartScreen(); 
                        alert("Error loading save data. It might be corrupted.");
                        this.sound.playMusic('menuTheme'); 
                    }
                    return false;
                }
            }
            
            gameOver(message) {
                this.setGameState(GAME_STATE.GAME_OVER); 
                this.ui.showGameOverScreen(message);
            }
        }

        // --- Initialize Game ---
        document.addEventListener('DOMContentLoaded', () => {
            const game = new Game();
        });

    </script>
</body>
</html>
