<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Desert Chronicles: The Arizona Artifact</title>
    <!-- Favicon -->
    <link rel="icon" href="../img/icon.png" type="image/png">
    <link rel="apple-touch-icon" href="../img/icon.png">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        :root {
            --vh: 1vh; /* Custom viewport height property for iOS */
        }
        
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column; 
            justify-content: center;
            align-items: center;
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100); /* iOS height fix */
            background-color: #121212;
            font-family: 'Press Start 2P', monospace;
            overflow: hidden;
            color: #FFF;
        }
        
        #gameContainer {
            position: relative;
            width: 640px;
            height: 480px;
            overflow: hidden;
            background-color: #000;
            box-shadow: 0 0 20px rgba(170, 114, 65, 0.7);
            border: 4px solid #8B4513;
            margin-bottom: 10px;
            /* Transition for screen shake */
            transition: transform 0.05s ease-in-out;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
        }
        
        #uiContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
        }

        #dialogBox, #puzzleScreen, #winScreen {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.9);
            color: #FFF;
            border: 3px solid #8B4513;
            padding: 15px;
            font-size: 12px;
            display: none;
            z-index: 100;
            line-height: 1.5;
            text-align: center; 
        }
        #puzzleScreen, #winScreen {
            top: 50%;
            bottom: auto;
            transform: translateY(-50%);
            max-width: 80%;
            margin-left: auto;
            margin-right: auto;
            pointer-events: all; 
        }
        #puzzleScreen button, #winScreen button {
            background-color: #8B4513;
            color: #FFF;
            font-family: 'Press Start 2P', monospace;
            font-size: 14px;
            padding: 8px 15px;
            border: none;
            cursor: pointer;
            margin: 10px 5px 0 5px;
            display: block; 
            margin-left: auto;
            margin-right: auto;
        }
        #puzzleScreen button:hover, #winScreen button:hover {
            background-color: #AA5500;
        }
        #pixelTrophy {
            display: block;
            margin: 10px auto;
            width: 64px; 
            height: 64px; 
        }
        
        #inventory {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #8B4513;
            padding: 5px;
            display: flex;
            z-index: 50;
        }
        
        .invItem {
            width: 32px;
            height: 32px;
            border: 1px solid #666;
            margin: 2px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #FFF;
            background-color: #333;
            cursor: pointer;
        }
        .invItem:hover {
            border-color: #FFF;
        }
        
        #startScreen, #pauseScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            text-align: center;
            pointer-events: all;
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
        }
        
        #startScreen h1, #pauseScreen h1, #gameOverScreen h1, #winScreen h1 {
            color: #FFAA33;
            font-size: 24px;
            text-shadow: 3px 3px 0 #AA5500;
            margin-bottom: 10px;
        }
        
        #startScreen h2 {
            color: #FF6633;
            font-size: 16px;
            margin-bottom: 30px;
        }
        
        #startScreen p, #pauseScreen p, #gameOverScreen p, #winScreen p {
            color: #AAA;
            font-size: 10px;
            max-width: 80%;
            margin-bottom: 20px;
            line-height: 1.5;
        }
        
        #startScreen button, #pauseScreen button, #gameOverScreen button {
            background-color: #8B4513;
            color: #FFF;
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            padding: 10px 20px;
            border: none;
            cursor: pointer;
            margin-top: 10px;
            margin-bottom: 5px;
        }
        #startScreen button:hover, #pauseScreen button:hover, #gameOverScreen button:hover {
            background-color: #AA5500;
        }
        
        #loadingText {
            color: #FFAA33;
            font-size: 12px;
            margin-top: 20px;
        }
        
        .statusBar {
            position: absolute;
            top: 10px;
            height: 15px;
            background-color: #333;
            border: 2px solid #8B4513;
            font-size: 10px;
            line-height: 15px;
            color: white;
            padding-left: 5px;
            z-index: 50;
        }
        #hpBar { right: 120px; width: 100px; }
        #hpFill { width: 100%; height: 75%; background-color: #CC3333; }
        #hydrationBar { right: 10px; width: 100px; }
        #hydrationFill { width: 100%; height: 75%; background-color: #3377CC; }
        
        #mapNameDisplay {
            position: absolute;
            top: 40px; 
            right: 10px;
            color: #FFF;
            font-size: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px;
            border: 1px solid #8B4513;
            z-index: 50;
        }

        #questLogDisplay {
            position: absolute;
            bottom: 75px; 
            left: 10px;
            color: #FFF;
            font-size: 10px;
            background-color: rgba(0,0,0,0.6);
            padding: 8px;
            border: 1px solid #8B4513;
            z-index: 50;
            max-width: 200px;
            display: none; 
        }
        #questLogDisplay h3 {
            margin: 0 0 5px 0;
            font-size: 11px;
            color: #FFAA33;
        }
        #questLogDisplay ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #questLogDisplay li {
            margin-bottom: 3px;
        }
        #clockDisplay {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFF;
            font-size: 10px;
            background-color: rgba(0,0,0,0.7);
            padding: 5px 8px;
             border: 1px solid #8B4513;
            z-index: 50;
        }
         #saveNotification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            color: #FFAA33;
            padding: 20px;
            font-size: 14px;
            border: 2px solid #8B4513;
            z-index: 1000;
            display: none;
        }
        #footer {
            font-family: 'Press Start 2P', monospace;
            color: #AAA;
            font-size: 8px; /* Adjusted */
            text-align: center;
            margin-top: 25px; 
            width: 100%;
            padding-bottom: 5px; 
        }

        #footer a {
            color: inherit;
            text-decoration: none;
        }

        #footer a:hover {
            text-decoration: underline;
        }
        
        /* Virtual Controls for Mobile/Tablet */
        #virtualControls {
            display: none; /* Hidden by default for desktop */
            width: 100%;
            max-width: 640px;
            height: 120px;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            touch-action: none; /* Prevent browser's default touch actions */
            -webkit-user-select: none; /* Prevent text selection on iOS */
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        #joystickContainer {
            position: relative;
            width: 120px;
            height: 120px;
            margin-left: 20px;
        }
        
        #joystickBase {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(50, 50, 50, 0.7);
            border: 2px solid #8B4513;
            border-radius: 50%;
            touch-action: none;
        }
        
        #joystickStick {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: #8B4513;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            touch-action: none;
        }
        
        #buttonContainer {
            display: flex;
            gap: 10px;
            margin-right: 20px;
        }
        
        .controlButton {
            width: 50px;
            height: 50px;
            background-color: #8B4513;
            color: #FFF;
            border: none;
            border-radius: 50%;
            font-family: 'Press Start 2P', monospace;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        
        .controlButton:active {
            background-color: #AA5500;
            transform: scale(0.95);
        }
        
        /* Media query for tablets and mobile devices */
        @media (max-width: 1024px) {
            #virtualControls {
                display: flex;
            }
            
            #gameContainer {
                /* Make sure the game container fits on smaller screens */
                width: 95vw;
                height: calc(95vw * 0.75); /* Maintain aspect ratio */
                max-width: 640px;
                max-height: 480px;
                margin-top: 10px; /* Add space at top */
            }
            
            #controlsInfo {
                display: none; /* Hide keyboard controls on mobile */
            }
            
            /* Additional mobile-specific styling */
            body {
                height: auto;
                min-height: 100vh;
                padding: 10px; /* Add padding to prevent elements touching edges */
            }
            
            .statusBar {
                font-size: 8px; /* Smaller text on mobile */
            }
            
            /* Make dialog text more readable on small screens */
            #dialogBox, #puzzleScreen, #winScreen {
                font-size: 10px;
            }
            
            /* Improve button tap targets */
            #startScreen button, #pauseScreen button, #gameOverScreen button {
                padding: 12px 20px;
                margin-top: 15px;
                width: 80%; /* Make buttons wider on mobile */
                max-width: 250px;
            }
            
            /* Improve start screen on mobile */
            #startScreen h1 {
                font-size: 20px;
                margin-top: 0;
            }
            
            #startScreen h2 {
                font-size: 14px;
                margin-top: 5px;
                margin-bottom: 15px;
            }
            
            #startScreen p {
                font-size: 8px;
                margin-bottom: 10px;
                line-height: 1.4;
            }
            
            /* Scale for smaller phones */
            @media (max-width: 480px) {
                #joystickContainer {
                    width: 100px;
                    height: 100px;
                    margin-left: 10px;
                }
                
                #joystickStick {
                    width: 40px;
                    height: 40px;
                }
                
                .controlButton {
                    width: 45px;
                    height: 45px;
                    font-size: 16px;
                }
                
                #buttonContainer {
                    margin-right: 10px;
                }
                
                #startScreen p {
                    font-size: 7px;
                }
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="640" height="480"></canvas>
        <div id="uiContainer">
            <div id="inventory"></div>
            <div id="hpBar" class="statusBar">HP <div id="hpFill"></div></div>
            <div id="hydrationBar" class="statusBar">H2O <div id="hydrationFill"></div></div>
            <div id="mapNameDisplay">Sonoran Desert</div>
            <div id="clockDisplay">Day 1 - 08:00 AM</div>
            <div id="questLogDisplay">
                <h3>Active Quests:</h3>
                <ul id="questList"></ul>
            </div>
            <div id="dialogBox"></div>
            <div id="puzzleScreen">
                <h1 id="puzzleQuestion">Puzzle Question</h1>
                <button id="puzzleOptionA">Option A</button>
                <button id="puzzleOptionB">Option B</button>
                <button id="puzzleOptionC">Option C</button>
            </div>
            <div id="winScreen">
                <h1>YOU WIN!</h1>
                <p id="winMessage">Congratulations, Professor!</p>
                <svg id="pixelTrophy" width="64" height="64" viewBox="0 0 16 16" style="image-rendering: pixelated;">
                    <rect x="6" y="1" width="4" height="2" fill="#FFD700"/> <rect x="5" y="3" width="6" height="1" fill="#FFD700"/>
                    <rect x="4" y="4" width="8" height="2" fill="#FFD700"/> <rect x="7" y="6" width="2" height="5" fill="#C0C0C0"/>
                    <rect x="5" y="11" width="6" height="2" fill="#A0522D"/> <rect x="4" y="13" width="8" height="1" fill="#A0522D"/>
                </svg>
                <button id="winMainMenuButton">MAIN MENU</button>
            </div>
        </div>
        
        <div id="startScreen">
            <h1>DESERT CHRONICLES</h1>
            <h2>The Arizona Artifact</h2>
            <p>The year is 1986. Professor James Walker, retired archaeologist and computer enthusiast, finds himself drawn back into adventure when he discovers an ancient petroglyph map in his Scottsdale home.</p>
            <p>The map hints at a lost artifact hidden somewhere in the Arizona desert - one that may hold the key to understanding the advanced astronomical knowledge of ancient native civilizations.</p>
            <p>Armed with his trusty canteen, pocket computer, and decades of field experience, the Professor embarks on one last expedition...</p>
            <button id="startButton">START ADVENTURE</button>
            <!-- <button id="loadButton">LOAD GAME</button> -->
            <div id="loadingText" style="display: none;">Loading...</div>
            <div id="audioNote" style="color:#FFAA33; font-size:8px; margin-top:10px;">Tap anywhere for sound</div>
        </div>

        <div id="pauseScreen" style="display: none;">
            <h1>PAUSED</h1>
            <button id="resumeButton">RESUME</button>
            <!-- <button id="saveButton">SAVE GAME</button> -->
            <button id="mainMenuButton">MAIN MENU</button>
        </div>

        <div id="gameOverScreen" style="display: none;">
            <h1>GAME OVER</h1>
            <p id="gameOverMessage"></p>
            <button id="restartButton">RESTART</button>
            <button id="gameOverMainMenuButton">MAIN MENU</button>
        </div>
         <div id="saveNotification">Game Saved!</div>
    </div>
    
    <!-- Virtual Controls for mobile/tablet -->
    <div id="virtualControls">
        <div id="joystickContainer">
            <div id="joystickBase"></div>
            <div id="joystickStick"></div>
        </div>
        <div id="buttonContainer">
            <div class="controlButton" id="interactButton">E</div>
            <div class="controlButton" id="inventoryButton">I</div>
            <div class="controlButton" id="questButton">Q</div>
            <div class="controlButton" id="pauseButton">P</div>
        </div>
    </div>
    
    <div id="controlsInfo" style="font-size: 10px; margin-top: 10px; text-align:center; max-width: 640px;">
        Controls: WASD/Arrows - Move | E/Space - Interact | I - Inventory | Q - Quests | P - Pause
    </div>

    <script>
        // --- Core Game Constants ---
        const CANVAS_WIDTH = 640;
        const CANVAS_HEIGHT = 480;
        const PLAYER_SPEED = 2;
        const HYDRATION_RATE = 0.05; 
        const HYDRATION_PER_DRINK = 30;
        const GAME_TIME_MULTIPLIER = 60; 

        // --- Game States ---
        const GAME_STATE = {
            START_SCREEN: 'START_SCREEN',
            LOADING: 'LOADING',
            PLAYING: 'PLAYING',
            PAUSED: 'PAUSED',
            DIALOG: 'DIALOG',
            PUZZLE: 'PUZZLE', 
            WIN: 'WIN',       
            GAME_OVER: 'GAME_OVER',
        };

        class SoundManager {
            constructor() {
                this.sounds = {};
                this.music = {};
                this.masterVolume = 1.0;
                this.sfxVolume = 0.7; 
                this.musicVolume = 0.5; 
                this.currentMusic = null;
                this.audioInitialized = false;
                this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                this.audioContext = null;
                
                // Create an empty audio context for mobile that we'll resume on first interaction
                if (this.isMobile) {
                    try {
                        // Use AudioContext or webkitAudioContext (for Safari)
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        this.audioContext = new AudioContext();
                    } catch (e) {
                        console.warn('Web Audio API not supported.');
                    }
                }

                // Music
                this.music.menuTheme = new Audio('music/menu.mp3');
                this.music.firstScenarioTheme = new Audio('sounds/first_scenario.mp3');
                this.music.secondScenarioTheme = new Audio('sounds/second_scenario.mp3');
                this.music.thirdScenarioTheme = new Audio('sounds/third_scenario.mp3');
                this.music.hohokamTheme = new Audio('sounds/hohokam_theme.mp3'); 
                this.music.casaGrandeTheme = new Audio('sounds/casa_grande_theme.mp3');
                this.music.skyPeopleTheme = new Audio('sounds/sky_people_theme.mp3');
                this.music.whiteTanksTheme = new Audio('sounds/white_tanks_theme.mp3');
                this.music.asuLabTheme = new Audio('sounds/fourth_scenario.mp3'); 
                this.music.chamberTheme = new Audio('sounds/chamber_theme.mp3');


                // Sound Effects
                this.sounds.selectOption = new Audio('sounds/select_options.mp3');
                this.sounds.gameStart = new Audio('sounds/game_start.mp3');
                this.sounds.nextScenario = new Audio('sounds/next_scenario.mp3');
                this.sounds.playerHurt = new Audio('sounds/hurt.mp3');
                this.sounds.getCoin = new Audio('sounds/get_coin.mp3'); 
                this.sounds.getItem = new Audio('sounds/get_item.mp3'); 
                this.sounds.gameOver = new Audio('sounds/game_over.mp3');
                this.sounds.winGame = new Audio('sounds/win_game.mp3'); 
                this.sounds.puzzleCorrect = new Audio('sounds/puzzle_correct.mp3'); 
                this.sounds.puzzleIncorrect = new Audio('sounds/puzzle_incorrect.mp3'); 
                this.sounds.enemyAttack = new Audio('sounds/enemy_attack.mp3'); 
                this.sounds.enemyHit = new Audio('sounds/enemy_hit.mp3'); 
                this.sounds.enemyDie = new Audio('sounds/enemy_die.mp3'); 
                this.sounds.drink = new Audio('sounds/drink.mp3'); 
                this.sounds.toinkArrow = new Audio('sounds/toink_arrow.mp3');
                this.sounds.thunder = new Audio('sounds/thunder.mp3');

                // Preload all audio
                this.preloadAudio();
                
                // Set initial volumes
                Object.values(this.sounds).forEach(sound => {
                    sound.volume = this.masterVolume * this.sfxVolume;
                    // Add event listeners to handle mobile playback issues
                    sound.addEventListener('ended', () => sound.currentTime = 0);
                    sound.addEventListener('error', (e) => console.warn(`Error with sound:`, e));
                });
                
                Object.values(this.music).forEach(track => {
                    track.volume = this.masterVolume * this.musicVolume;
                    track.addEventListener('ended', () => track.currentTime = 0);
                    track.addEventListener('error', (e) => console.warn(`Error with music:`, e));
                });
            }
            
            // Preload all audio files to avoid delays
            preloadAudio() {
                const preloadAudio = (audio) => {
                    if (audio && audio.src) {
                        audio.load();
                    }
                };
                
                Object.values(this.sounds).forEach(preloadAudio);
                Object.values(this.music).forEach(preloadAudio);
            }
            
            // Initialize audio on first user interaction (for mobile)
            initializeAudio() {
                if (this.audioInitialized) return;
                
                if (this.isMobile && this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume().then(() => {
                        console.log('AudioContext resumed');
                    }).catch(e => {
                        console.warn('Error resuming AudioContext:', e);
                    });
                }
                
                // Create silent audio and play it to unlock audio on iOS
                if (this.isMobile) {
                    const silentSound = new Audio();
                    silentSound.src = 'data:audio/mp3;base64,SUQzBAAAAAABEUAAACgAZHRlYWNoZXIgdGVzdCBmaWxlIEJlZXAgdG9uZQAAAAAAAAAAAA==';
                    silentSound.play().catch(e => console.warn('Silent sound play failed:', e));
                    
                    // Touch-enable all audio elements
                    Object.values(this.sounds).concat(Object.values(this.music)).forEach(audio => {
                        audio.load();
                        // iOS often requires play() even if immediately followed by pause()
                        audio.play().catch(() => {}).then(() => audio.pause());
                        audio.currentTime = 0;
                    });
                }
                
                this.audioInitialized = true;
            }

            playSound(soundName) {
                if (!this.audioInitialized) {
                    this.initializeAudio();
                }
                
                if (this.sounds[soundName]) {
                    // Create a clone for overlapping sounds
                    const sound = this.sounds[soundName];
                    sound.currentTime = 0;
                    
                    sound.play().catch(e => {
                        console.warn(`Error playing sound ${soundName}:`, e);
                        // For iOS, we need to retry after a user interaction
                        if (e.name === 'NotAllowedError' && this.isMobile) {
                            document.body.addEventListener('touchstart', () => {
                                sound.play().catch(() => {});
                            }, { once: true });
                        }
                    });
                } else {
                    console.warn(`Sound not found: ${soundName}`);
                }
            }

            playMusic(musicName, loop = true) {
                if (!this.audioInitialized) {
                    this.initializeAudio();
                }
                
                if (this.currentMusic && this.music[this.currentMusic]) {
                    this.music[this.currentMusic].pause();
                    this.music[this.currentMusic].currentTime = 0;
                }
                
                if (this.music[musicName]) {
                    const music = this.music[musicName];
                    music.loop = loop;
                    music.play().catch(e => {
                        console.warn(`Error playing music ${musicName}:`, e);
                        // For iOS, we need to retry after a user interaction
                        if (e.name === 'NotAllowedError' && this.isMobile) {
                            document.body.addEventListener('touchstart', () => {
                                music.play().catch(() => {});
                            }, { once: true });
                        }
                    });
                    this.currentMusic = musicName;
                } else {
                     console.warn(`Music not found: ${musicName}`);
                }
            }

            stopMusic(specificMusicName = null) {
                if (specificMusicName && this.music[specificMusicName]) {
                     this.music[specificMusicName].pause();
                     this.music[specificMusicName].currentTime = 0;
                     if (this.currentMusic === specificMusicName) {
                         this.currentMusic = null;
                     }
                } else if (this.currentMusic && this.music[this.currentMusic]) { 
                    this.music[this.currentMusic].pause();
                    this.music[this.currentMusic].currentTime = 0;
                    this.currentMusic = null;
                }
            }

            pauseCurrentMusic() {
                if (this.currentMusic && this.music[this.currentMusic]) {
                    this.music[this.currentMusic].pause();
                }
            }

            resumeCurrentMusic() {
                if (this.currentMusic && this.music[this.currentMusic]) {
                    this.music[this.currentMusic].play().catch(e => {
                        console.warn(`Error resuming music ${this.currentMusic}:`, e);
                        // For iOS, try to resume after user interaction
                        if (e.name === 'NotAllowedError' && this.isMobile) {
                            document.body.addEventListener('touchstart', () => {
                                this.music[this.currentMusic].play().catch(() => {});
                            }, { once: true });
                        }
                    });
                }
            }
        }

        class InputHandler {
            constructor(game) {
                this.game = game;
                this.keys = {};
                this.isVirtualJoystickActive = false;
                this.joystickDirection = { x: 0, y: 0 };
                this.virtualControlsActive = false;
                
                // Keyboard input
                window.addEventListener('keydown', (e) => this.keys[e.key.toLowerCase()] = true);
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                    this.game.handleKeyUp(e.key.toLowerCase()); 
                });
                
                // Check if mobile/tablet and set up virtual controls if needed
                this.checkDeviceType();
                window.addEventListener('resize', () => this.checkDeviceType());
            }
            
            checkDeviceType() {
                const isMobile = window.innerWidth <= 1024;
                
                // Only set up virtual controls if we're on mobile and they haven't been set up yet
                if (isMobile && !this.virtualControlsActive) {
                    this.setupVirtualControls();
                    this.virtualControlsActive = true;
                }
            }

            setupVirtualControls() {
                // Only set up virtual controls if they exist in the DOM
                const joystickStick = document.getElementById('joystickStick');
                const joystickBase = document.getElementById('joystickBase');
                const interactButton = document.getElementById('interactButton');
                const inventoryButton = document.getElementById('inventoryButton');
                const questButton = document.getElementById('questButton');
                const pauseButton = document.getElementById('pauseButton');
                
                if (!joystickStick || !joystickBase) return;
                
                // Joystick variables
                let baseRect = joystickBase.getBoundingClientRect();
                let baseX = baseRect.width / 2;
                let baseY = baseRect.height / 2;
                let maxDistance = baseRect.width / 2 - joystickStick.clientWidth / 2;
                
                // Function to update joystick position reference values - call on resize or orientation change
                const updateJoystickMeasurements = () => {
                    baseRect = joystickBase.getBoundingClientRect();
                    baseX = baseRect.width / 2;
                    baseY = baseRect.height / 2;
                    maxDistance = baseRect.width / 2 - joystickStick.clientWidth / 2;
                };
                
                // Update measurements on resize or orientation change
                window.addEventListener('resize', updateJoystickMeasurements);
                window.addEventListener('orientationchange', updateJoystickMeasurements);
                
                // Touch handling for joystick
                const handleJoystickTouch = (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    // Recalculate baseRect on each touch to ensure accuracy
                    baseRect = joystickBase.getBoundingClientRect();
                    
                    const touchX = touch.clientX - baseRect.left;
                    const touchY = touch.clientY - baseRect.top;
                    
                    // Calculate distance from center
                    const deltaX = touchX - baseX;
                    const deltaY = touchY - baseY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    if (distance > maxDistance) {
                        // Normalize if distance exceeds the max
                        const angle = Math.atan2(deltaY, deltaX);
                        const limitedX = baseX + Math.cos(angle) * maxDistance;
                        const limitedY = baseY + Math.sin(angle) * maxDistance;
                        joystickStick.style.left = limitedX + 'px';
                        joystickStick.style.top = limitedY + 'px';
                        
                        // Calculate direction (normalized)
                        this.joystickDirection.x = Math.cos(angle);
                        this.joystickDirection.y = Math.sin(angle);
                    } else {
                        // Use exact position if within bounds
                        joystickStick.style.left = touchX + 'px';
                        joystickStick.style.top = touchY + 'px';
                        
                        // Calculate direction
                        this.joystickDirection.x = deltaX / maxDistance;
                        this.joystickDirection.y = deltaY / maxDistance;
                    }
                    
                    this.isVirtualJoystickActive = true;
                    
                    // Set virtual key states based on joystick direction
                    this.keys['arrowup'] = this.joystickDirection.y < -0.3;
                    this.keys['arrowdown'] = this.joystickDirection.y > 0.3;
                    this.keys['arrowleft'] = this.joystickDirection.x < -0.3;
                    this.keys['arrowright'] = this.joystickDirection.x > 0.3;
                };
                
                const resetJoystick = () => {
                    joystickStick.style.left = '50%';
                    joystickStick.style.top = '50%';
                    this.joystickDirection = { x: 0, y: 0 };
                    this.isVirtualJoystickActive = false;
                    
                    // Reset virtual key states
                    this.keys['arrowup'] = false;
                    this.keys['arrowdown'] = false;
                    this.keys['arrowleft'] = false;
                    this.keys['arrowright'] = false;
                };
                
                // Joystick event listeners
                joystickBase.addEventListener('touchstart', handleJoystickTouch);
                joystickBase.addEventListener('touchmove', handleJoystickTouch);
                joystickBase.addEventListener('touchend', resetJoystick);
                joystickBase.addEventListener('touchcancel', resetJoystick);
                
                // Button event listeners
                if (interactButton) {
                    interactButton.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.keys['e'] = true;
                    });
                    interactButton.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.keys['e'] = false;
                        this.game.handleKeyUp('e');
                    });
                }
                
                if (inventoryButton) {
                    inventoryButton.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.keys['i'] = true;
                    });
                    inventoryButton.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.keys['i'] = false;
                        this.game.handleKeyUp('i');
                    });
                }
                
                if (questButton) {
                    questButton.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.keys['q'] = true;
                    });
                    questButton.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.keys['q'] = false;
                        this.game.handleKeyUp('q');
                    });
                }
                
                if (pauseButton) {
                    pauseButton.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.keys['p'] = true;
                    });
                    pauseButton.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.keys['p'] = false;
                        this.game.handleKeyUp('p');
                    });
                }
                
                // Prevent default on all button touch events to avoid scrolling
                document.querySelectorAll('.controlButton').forEach(button => {
                    button.addEventListener('touchstart', (e) => e.preventDefault());
                    button.addEventListener('touchmove', (e) => e.preventDefault());
                    button.addEventListener('touchend', (e) => e.preventDefault());
                });
                
                // Initialize joystick position
                resetJoystick();
            }

            isPressed(key) {
                return this.keys[key] || false;
            }
        }

        class UIManager {
            constructor(game) {
                this.game = game;
                this.canvas = document.getElementById('gameCanvas'); 
                this.ctx = this.canvas.getContext('2d');
                this.dialogBox = document.getElementById('dialogBox');
                this.inventoryDiv = document.getElementById('inventory');
                this.hpFill = document.getElementById('hpFill');
                this.hydrationFill = document.getElementById('hydrationFill');
                this.mapNameDisplay = document.getElementById('mapNameDisplay');
                this.clockDisplay = document.getElementById('clockDisplay');
                this.questLogDisplay = document.getElementById('questLogDisplay');
                this.questList = document.getElementById('questList');
                
                this.startScreen = document.getElementById('startScreen');
                this.pauseScreen = document.getElementById('pauseScreen');
                this.gameOverScreen = document.getElementById('gameOverScreen');
                this.loadingText = document.getElementById('loadingText');
                this.saveNotification = document.getElementById('saveNotification');

                this.puzzleScreen = document.getElementById('puzzleScreen');
                this.puzzleQuestion = document.getElementById('puzzleQuestion');
                this.puzzleOptionA = document.getElementById('puzzleOptionA');
                this.puzzleOptionB = document.getElementById('puzzleOptionB');
                this.puzzleOptionC = document.getElementById('puzzleOptionC');
                this.winScreen = document.getElementById('winScreen');
                this.winMessage = document.getElementById('winMessage');


                document.getElementById('startButton').addEventListener('click', () => {
                    this.game.sound.initializeAudio(); // Initialize audio on first interaction
                    this.game.sound.stopMusic('menuTheme');
                    this.game.sound.playSound('selectOption');
                    this.game.startGame();
                });
                /*
                document.getElementById('loadButton').addEventListener('click', () => {
                    this.game.sound.initializeAudio(); // Initialize audio on first interaction
                    this.game.sound.stopMusic('menuTheme');
                    this.game.sound.playSound('selectOption');
                    this.game.loadGame(true);
                });
                */
                document.getElementById('resumeButton').addEventListener('click', () => {
                    this.game.sound.initializeAudio(); // Ensure audio is initialized
                    this.game.togglePause();
                });
                /*
                document.getElementById('saveButton').addEventListener('click', () => {
                    this.game.sound.initializeAudio(); // Ensure audio is initialized
                    this.game.saveGame();
                });
                */
                document.getElementById('mainMenuButton').addEventListener('click', () => {
                    this.game.sound.initializeAudio(); // Ensure audio is initialized
                    this.game.goToMainMenu();
                });
                document.getElementById('restartButton').addEventListener('click', () => {
                     this.game.sound.initializeAudio(); // Ensure audio is initialized
                     this.game.sound.playSound('selectOption');
                     this.game.startGame(true);
                });
                document.getElementById('gameOverMainMenuButton').addEventListener('click', () => {
                    this.game.sound.initializeAudio(); // Ensure audio is initialized
                    this.game.sound.playSound('selectOption');
                    this.game.goToMainMenu();
                });
                document.getElementById('winMainMenuButton').addEventListener('click', () => {
                    this.game.sound.initializeAudio(); // Ensure audio is initialized
                    this.game.sound.playSound('selectOption');
                    this.game.goToMainMenu();
                });

                this.puzzleOptionA.addEventListener('click', () => this.game.handlePuzzleAnswer(0));
                this.puzzleOptionB.addEventListener('click', () => this.game.handlePuzzleAnswer(1));
                this.puzzleOptionC.addEventListener('click', () => this.game.handlePuzzleAnswer(2));
            }

            showStartScreen() { this.startScreen.style.display = 'flex'; }
            hideStartScreen() { this.startScreen.style.display = 'none'; }
            showPauseScreen() { this.pauseScreen.style.display = 'flex'; }
            hidePauseScreen() { this.pauseScreen.style.display = 'none'; }
            showGameOverScreen(message) {
                document.getElementById('gameOverMessage').textContent = message;
                this.gameOverScreen.style.display = 'flex';
            }
            hideGameOverScreen() { this.gameOverScreen.style.display = 'none'; }
            
            showLoading() { this.loadingText.style.display = 'block';}
            hideLoading() { this.loadingText.style.display = 'none';}

            updateHealth(current, max) { this.hpFill.style.width = `${(current / max) * 100}%`; }
            updateHydration(current, max) { this.hydrationFill.style.width = `${(current / max) * 100}%`; }
            updateMapName(name) { this.mapNameDisplay.textContent = name; }

            updateClock(gameTimeInSeconds) {
                const day = Math.floor(gameTimeInSeconds / (24 * 60 * 60)) + 1;
                const totalSecondsInDay = gameTimeInSeconds % (24 * 60 * 60);
                const hours = Math.floor(totalSecondsInDay / 3600);
                const minutes = Math.floor((totalSecondsInDay % 3600) / 60);
                const ampm = hours >= 12 ? 'PM' : 'AM';
                const displayHours = hours % 12 === 0 ? 12 : hours % 12;
                this.clockDisplay.textContent = `Day ${day} - ${String(displayHours).padStart(2, '0')}:${String(minutes).padStart(2, '0')} ${ampm}`;
            }
            
            showDialog(text, speaker) {
                this.dialogBox.innerHTML = speaker ? `<strong>${speaker}:</strong> ${text}` : text;
                this.dialogBox.style.display = 'block';
            }
            hideDialog() { this.dialogBox.style.display = 'none'; }

            showPuzzle(question, options) {
                this.puzzleQuestion.textContent = question;
                this.puzzleOptionA.textContent = `A. ${options[0]}`;
                this.puzzleOptionB.textContent = `B. ${options[1]}`;
                this.puzzleOptionC.textContent = `C. ${options[2]}`;
                this.puzzleScreen.style.display = 'block';
            }
            hidePuzzle() { this.puzzleScreen.style.display = 'none'; }

            showWinScreen(message) {
                this.winMessage.textContent = message;
                this.winScreen.style.display = 'block';
            }
            hideWinScreen() { this.winScreen.style.display = 'none'; }


            updateInventoryDisplay(inventory, itemTypes) {
                this.inventoryDiv.innerHTML = '';
                inventory.forEach(itemKey => {
                    const item = itemTypes[itemKey];
                    if (!item) return;
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'invItem';
                    itemDiv.textContent = item.name.charAt(0).toUpperCase();
                    itemDiv.title = `${item.name}: ${item.description}`;
                    itemDiv.addEventListener('click', () => this.game.useItem(itemKey));
                    this.inventoryDiv.appendChild(itemDiv);
                });
            }

            updateQuestLog(quests) {
                if (quests.length === 0) {
                    this.questLogDisplay.style.display = 'none';
                    return;
                }
                this.questLogDisplay.style.display = 'block';
                this.questList.innerHTML = '';
                quests.forEach(quest => {
                    const li = document.createElement('li');
                    li.textContent = quest.description + (quest.completed ? " (Completed)" : "");
                    if(quest.completed) li.style.textDecoration = "line-through";
                    this.questList.appendChild(li);
                });
            }
            
            toggleQuestLog() {
                this.questLogDisplay.style.display = this.questLogDisplay.style.display === 'none' ? 'block' : 'none';
            }

            drawInteractionIndicator(x, y) {
                this.ctx.fillStyle = '#FFFF00';
                this.ctx.beginPath();
                this.ctx.arc(x, y - 35, 5, 0, Math.PI * 2);
                this.ctx.fill();
            }

            showSaveNotification() {
                this.saveNotification.style.display = 'block';
                setTimeout(() => {
                    this.saveNotification.style.display = 'none';
                }, 1500);
            }
        }
        
        class Entity {
            constructor(game, x, y, width, height, type = 'entity') {
                this.game = game;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.animationFrame = 0;
                this.spriteIndex = 0; 
            }

            draw(ctx) { /* Base draw method */ }
            update() { /* Base update method */ }
            
            get centerX() { return this.x + this.width / 2; }
            get centerY() { return this.y + this.height / 2; }
        }

        class Player extends Entity {
            constructor(game, x, y) {
                super(game, x, y, 24, 32, 'player'); 
                this.collisionBox = { xOffset: 4, yOffset: 16, width: 16, height: 16 }; 
                this.speed = PLAYER_SPEED;
                this.direction = 'down';
                this.health = 100;
                this.maxHealth = 100;
                this.hydration = 100;
                this.maxHydration = 100;
                this.inventory = ['canteen', 'compass'];
                this.quests = [ {id: "main_artifact", description: "Find the Arizona Artifact.", completed: false}];
                this.isMoving = false;
            }

            update() {
                this.isMoving = false;
                let nextX = this.x;
                let nextY = this.y;
                let moveX = 0;
                let moveY = 0;

                if (this.game.input.isPressed('w') || this.game.input.isPressed('arrowup')) {
                    moveY = -this.speed; this.direction = 'up'; this.isMoving = true;
                } else if (this.game.input.isPressed('s') || this.game.input.isPressed('arrowdown')) {
                    moveY = this.speed; this.direction = 'down'; this.isMoving = true;
                }
                if (this.game.input.isPressed('a') || this.game.input.isPressed('arrowleft')) {
                    moveX = -this.speed; this.direction = 'left'; this.isMoving = true;
                } else if (this.game.input.isPressed('d') || this.game.input.isPressed('arrowright')) {
                    moveX = this.speed; this.direction = 'right'; this.isMoving = true;
                }
                
                nextX += moveX;
                nextY += moveY;

                if (!this.game.currentMap.checkCollision(nextX + this.collisionBox.xOffset, this.y + this.collisionBox.yOffset, this.collisionBox.width, this.collisionBox.height)) {
                    this.x = nextX;
                }
                if (!this.game.currentMap.checkCollision(this.x + this.collisionBox.xOffset, nextY + this.collisionBox.yOffset, this.collisionBox.width, this.collisionBox.height)) {
                    this.y = nextY;
                }

                this.x = Math.max(0, Math.min(this.x, CANVAS_WIDTH - this.width));
                this.y = Math.max(0, Math.min(this.y, CANVAS_HEIGHT - this.height));

                this.animationFrame++;
                if (this.animationFrame % 8 === 0 && this.isMoving) {
                    this.spriteIndex = (this.spriteIndex + 1) % 4; 
                } else if (!this.isMoving) {
                    this.spriteIndex = 0; 
                }

                this.hydration -= HYDRATION_RATE / 60; 
                if (this.hydration < 0) this.hydration = 0;
                if (this.hydration === 0 && this.animationFrame % 120 === 0) { 
                    this.takeDamage(1, "Dehydration");
                }
                this.game.ui.updateHydration(this.hydration, this.maxHydration);
            }

            draw(ctx) {
                ctx.fillStyle = '#CC3333'; // Body color
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#DDBB99'; // Head color
                ctx.fillRect(this.x + (this.width/2) - 8, this.y - 14, 16, 16); 
                ctx.fillStyle = '#8B4513'; // Hat color
                ctx.fillRect(this.x + (this.width/2) - 10, this.y - 20, 20, 6);
                // Simple leg animation
                const legOffset = this.isMoving ? Math.sin(this.animationFrame * 0.2) * 3 : 0;
                ctx.fillStyle = '#AA2222'; // Darker red for legs
                ctx.fillRect(this.x + 4, this.y + this.height - 8 + legOffset, 6, 8);
                ctx.fillRect(this.x + this.width - 10, this.y + this.height - 8 - legOffset, 6, 8);
            }

            interact() {
                const checkRange = 20; 
                let checkX = this.x + this.width / 2;
                let checkY = this.y + this.height / 2;

                switch (this.direction) {
                    case 'up': checkY -= this.height / 2 + checkRange / 2; break;
                    case 'down': checkY += this.height / 2 + checkRange / 2; break;
                    case 'left': checkX -= this.width / 2 + checkRange / 2; break;
                    case 'right': checkX += this.width / 2 + checkRange / 2; break;
                }
                this.game.currentMap.tryInteraction(checkX, checkY, this);
            }

            addItem(itemKey) {
                if (!this.inventory.includes(itemKey)) {
                    this.inventory.push(itemKey);
                    this.game.ui.updateInventoryDisplay(this.inventory, this.game.itemTypes);
                    if (itemKey === 'artifact1' || itemKey === 'final_artifact') { 
                        this.game.sound.playSound('getCoin');
                    } else {
                        this.game.sound.playSound('getItem'); 
                    }
                    return true;
                }
                return false;
            }
            
            hasItem(itemKey) {
                return this.inventory.includes(itemKey);
            }

            takeDamage(amount, source = "Unknown") {
                this.health -= amount;
                if (this.health < 0) this.health = 0;
                this.game.ui.updateHealth(this.health, this.maxHealth);

                const enemySource = source.toLowerCase();
                if (enemySource.includes('coyote') || enemySource.includes('snake') || enemySource.includes('spider') || enemySource.includes('spirit') || source === 'Arrow') {
                    this.game.sound.playSound('playerHurt');
                } else if (source !== "Dehydration") { 
                     this.game.sound.playSound('playerHurt'); 
                }
                
                // Screen flash effect
                this.game.canvas.style.backgroundColor = '#FF0000'; // Flash red
                setTimeout(() => { this.game.canvas.style.backgroundColor = ''; }, 100); // Reset background

                if (this.health <= 0) {
                    this.game.gameOver(`Defeated by ${source}.`);
                }
            }

            heal(amount) {
                this.health = Math.min(this.maxHealth, this.health + amount);
                this.game.ui.updateHealth(this.health, this.maxHealth);
            }

            hydrate(amount) {
                this.hydration = Math.min(this.maxHydration, this.hydration + amount);
                this.game.ui.updateHydration(this.hydration, this.maxHydration);
            }
            
            addQuest(quest) { 
                if (!this.quests.find(q => q.id === quest.id)) {
                    this.quests.push(quest);
                    this.game.ui.updateQuestLog(this.quests);
                }
            }
            
            completeQuest(questId) {
                const quest = this.quests.find(q => q.id === questId);
                if (quest && !quest.completed) { 
                    quest.completed = true;
                    this.game.ui.updateQuestLog(this.quests);
                    this.game.ui.showDialog(`Quest Completed: ${quest.description}`, "System");
                }
            }
        }
        
        class NPC extends Entity {
            constructor(game, x, y, name, spriteKey, dialog) {
                super(game, x, y, 24, 32, 'npc'); 
                this.name = name;
                this.spriteKey = spriteKey; // Placeholder for potential future sprite system
                this.dialog = dialog; 
                this.isInteractable = true;
                if (Array.isArray(this.dialog)) { // If dialog is an array, cycle through it
                    this.dialogIndex = 0; 
                }
            }

            draw(ctx) {
                // Simple NPC representation
                ctx.fillStyle = '#5577AA'; // Blueish color for NPC
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#DDBB99'; // Head color
                ctx.fillRect(this.x + 4, this.y - 14, 16, 16); 
                // NPC Name Tag
                ctx.fillStyle = '#FFFFFF'; 
                ctx.font = '8px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, this.x + this.width / 2, this.y - 20);
                ctx.textAlign = 'left'; // Reset alignment
            }

            onInteract(player) {
                let currentDialog = this.dialog;
                if (typeof this.dialog === 'function') {
                    currentDialog = this.dialog(player, this.game); // Dynamic dialog based on player state
                } else if (Array.isArray(this.dialog)) {
                    currentDialog = this.dialog[this.dialogIndex];
                    this.dialogIndex = (this.dialogIndex + 1) % this.dialog.length; // Cycle dialog
                }
                this.game.ui.showDialog(currentDialog, this.name); 
                this.game.setGameState(GAME_STATE.DIALOG); 
            }
        }
        
        class Enemy extends Entity {
            constructor(game, x, y, enemyTypeData) {
                super(game, x, y, enemyTypeData.width, enemyTypeData.height, 'enemy');
                this.enemyType = enemyTypeData; 
                this.health = enemyTypeData.health;
                this.speed = enemyTypeData.speed;
                this.damage = enemyTypeData.damage;
                this.aggroRange = enemyTypeData.aggroRange || 150;
                this.attackRange = enemyTypeData.attackRange || 20; 
                this.attackCooldown = enemyTypeData.attackCooldown || 120; // Frames
                this.currentAttackCooldown = 0;
                this.isEthereal = enemyTypeData.isEthereal || false; // For ghosts
            }

            update() {
                if (this.currentAttackCooldown > 0) this.currentAttackCooldown--;

                const player = this.game.player;
                const distX = player.centerX - this.centerX;
                const distY = player.centerY - this.centerY;
                const distanceToPlayer = Math.sqrt(distX * distX + distY * distY);

                if (distanceToPlayer < this.aggroRange) {
                    // Move towards player if not in attack range
                    if (distanceToPlayer > this.attackRange) {
                        this.x += (distX / distanceToPlayer) * this.speed;
                        this.y += (distY / distanceToPlayer) * this.speed;
                    } else if (this.currentAttackCooldown === 0) { // Attack if in range and cooldown is over
                        player.takeDamage(this.damage, this.enemyType.name); 
                        this.currentAttackCooldown = this.attackCooldown;
                        this.game.sound.playSound('enemyAttack'); 
                        // Optional: Knockback effect
                        this.x -= (distX / distanceToPlayer) * 10; // Move back slightly
                        this.y -= (distY / distanceToPlayer) * 10;
                    }
                }
            }

            draw(ctx) {
                if (this.isEthereal) ctx.globalAlpha = 0.7; // Make ghosts slightly transparent
                ctx.fillStyle = this.enemyType.color || '#FF0000'; // Default to red if no color specified
                ctx.fillRect(this.x, this.y, this.width, this.height);
                if (this.isEthereal) ctx.globalAlpha = 1.0; // Reset alpha

                // Health bar above enemy
                if (this.health < this.enemyType.health) {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x, this.y - 8, this.width, 4);
                    ctx.fillStyle = 'green';
                    ctx.fillRect(this.x, this.y - 8, this.width * (this.health / this.enemyType.health) , 4);
                }
            }

            takeDamage(amount) {
                this.health -= amount;
                this.game.sound.playSound('enemyHit');
                if (this.health <= 0) {
                    this.game.currentMap.removeEnemy(this);
                    this.game.sound.playSound('enemyDie');
                }
            }
        }

        class Arrow extends Entity {
            constructor(game, x, y, targetX, targetY, speed, damage) {
                super(game, x, y, 8, 4, 'projectile'); // Small arrow
                this.speed = speed;
                this.damage = damage;
                const angle = Math.atan2(targetY - y, targetX - x);
                this.dx = Math.cos(angle) * this.speed;
                this.dy = Math.sin(angle) * this.speed;
                this.lifeSpan = 180; // Frames before arrow disappears (3 seconds at 60fps)
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.lifeSpan--;

                // Check collision with player
                const player = this.game.player;
                if (this.x < player.x + player.width &&
                    this.x + this.width > player.x &&
                    this.y < player.y + player.height &&
                    this.y + this.height > player.y) {
                    player.takeDamage(this.damage, "Arrow");
                    this.lifeSpan = 0; // Mark for removal
                }

                // Check map boundaries
                if (this.x < 0 || this.x > CANVAS_WIDTH || this.y < 0 || this.y > CANVAS_HEIGHT) {
                    this.lifeSpan = 0; // Mark for removal
                }
            }

            draw(ctx) {
                ctx.fillStyle = '#CD853F'; // Brownish color for arrow
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }


        class InteractiveObject extends Entity {
            constructor(game, x, y, objData) {
                super(game, x, y, objData.width, objData.height, objData.type);
                this.objData = JSON.parse(JSON.stringify(objData)); // Deep copy to prevent shared state
                this.isInteractable = this.objData.interactive || this.objData.portal || this.objData.portalOnInteract || this.objData.triggersPuzzle;
                
                // Skull Turret specific properties
                if (this.type === 'skull_turret') {
                    this.attackCooldown = 180; // Shoots every 3 seconds
                    this.currentAttackCooldown = Math.random() * this.attackCooldown; // Stagger initial shots
                    this.arrowSpeed = 3;
                    this.arrowDamage = 10;
                    this.aggroRange = 200;
                }
            }
            
            // Specific update for skull turret, called by GameMap
            updateTurret() {
                if (this.type !== 'skull_turret' || this.game.gameState !== GAME_STATE.PLAYING) return;

                this.currentAttackCooldown--;
                const player = this.game.player;
                const distX = player.centerX - this.centerX;
                const distY = player.centerY - this.centerY;
                const distanceToPlayer = Math.sqrt(distX * distX + distY * distY);

                if (distanceToPlayer < this.aggroRange && this.currentAttackCooldown <= 0) {
                    this.game.currentMap.addProjectile(new Arrow(this.game, this.centerX, this.centerY, player.centerX, player.centerY, this.arrowSpeed, this.arrowDamage));
                    this.game.sound.playSound('toinkArrow'); // Sound should play here
                    this.currentAttackCooldown = this.attackCooldown;
                }
            }


            draw(ctx) {
                ctx.fillStyle = this.objData.color || '#888888'; // Default color
                if (this.type === 'cactus') {
                    ctx.fillStyle = '#2D7D40'; ctx.fillRect(this.x + 8, this.y, 16, 32); ctx.fillRect(this.x, this.y + 8, 32, 16);
                } else if (this.type === 'rock') {
                    ctx.fillStyle = '#7D7064'; ctx.beginPath(); ctx.arc(this.x + 16, this.y + 16, 16, 0, Math.PI * 2); ctx.fill();
                } else if (this.type === 'chest') {
                    ctx.fillStyle = this.objData.opened ? '#654321' : '#8B4513'; // Opened/Closed chest
                    ctx.fillRect(this.x, this.y + 10, this.width, this.height - 10);
                    ctx.fillStyle = '#DAA520'; ctx.fillRect(this.x + this.width/2 - 2, this.y + this.height/2, 4, 10); // Lock
                } else if (this.type === 'sign' || this.type === 'interactive_point' || this.type === 'petroglyph_panel' || this.type === 'ancient_symbol') {
                    ctx.fillStyle = '#8B4513'; ctx.fillRect(this.x + this.width/2 - 4, this.y + this.height/2, 8, this.height/2); // Post
                    ctx.fillStyle = '#DAA520'; ctx.fillRect(this.x, this.y, this.width, this.height/2); // Signboard
                    if (this.type === 'petroglyph_panel') { ctx.fillStyle = '#4A2A0A'; ctx.font = '6px "Press Start 2P"'; ctx.fillText("PETRO", this.x+2, this.y+8);}
                    if (this.type === 'ancient_symbol') { ctx.fillStyle = '#E0E0E0'; ctx.font = '10px "Press Start 2P"'; ctx.fillText("?", this.x+this.width/2-5, this.y+this.height/2+5);}
                } else if (this.type === 'water_source') {
                    ctx.fillStyle = '#3377CC'; ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.fillStyle = '#66AADD'; ctx.fillRect(this.x + 4, this.y + 4, this.width - 8, this.height - 8); // Inner water
                } else if (this.type === 'doorway' || (this.type === 'secret_panel' && this.objData.isNowPortal)) {
                    ctx.fillStyle = '#555555'; ctx.fillRect(this.x, this.y, this.width, this.height);
                     if (this.objData.text) { // Display text above doorway if available
                        ctx.fillStyle = '#FFFFFF'; ctx.font = '8px "Press Start 2P"'; ctx.textAlign = 'center';
                        ctx.fillText(this.objData.text.substring(0,10)+"...", this.x + this.width/2, this.y - 5);
                        ctx.textAlign = 'left';
                    }
                } else if (this.type === 'computer_terminal') {
                    ctx.fillStyle = '#222'; ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.fillStyle = '#3F3'; ctx.fillRect(this.x+2, this.y+2, this.width-4, this.height-4); // Screen
                } else if (this.type === 'lab_bench') {
                    ctx.fillStyle = '#777'; ctx.fillRect(this.x, this.y, this.width, this.height);
                } else if (this.type === 'server_rack') {
                    ctx.fillStyle = '#333'; ctx.fillRect(this.x, this.y, this.width, this.height);
                    for(let i=0; i<4; i++) { ctx.fillStyle = i%2==0 ? '#0F0':'#0A0'; ctx.fillRect(this.x+4, this.y+4 + i*8, 8, 4); } // Blinky lights
                } else if (this.type === 'secret_panel' && !this.objData.isNowPortal) {
                     ctx.fillStyle = '#6B5B4B'; ctx.fillRect(this.x, this.y, this.width, this.height);
                } else if (this.type === 'pedestal') {
                    ctx.fillStyle = '#8888AA'; ctx.fillRect(this.x, this.y, this.width, this.height);
                    if (!this.objData.opened && (!this.game.player || !this.game.player.hasItem('final_artifact'))) { // Show artifact if not taken
                         ctx.fillStyle = '#FFD700'; 
                         ctx.fillRect(this.x + this.width/4, this.y + this.height/4, this.width/2, this.height/2);
                    }
                } else if (this.type === 'hohokam_canal') {
                    ctx.fillStyle = '#658EA9'; ctx.fillRect(this.x, this.y, this.width, this.height); 
                } else if (this.type === 'platform_mound') {
                    ctx.fillStyle = '#B08D57'; ctx.fillRect(this.x, this.y, this.width, this.height); 
                } else if (this.type === 'sky_hole_wall') {
                    ctx.fillStyle = '#A08C78'; ctx.fillRect(this.x, this.y, this.width, this.height); 
                    ctx.fillStyle = '#000020'; ctx.beginPath(); ctx.arc(this.x + this.width/2, this.y + this.height/2, 4, 0, Math.PI*2); ctx.fill(); // Sky hole
                } else if (this.type === 'phoenix_statue') {
                    ctx.fillStyle = '#FF8C00'; // Orange
                    ctx.beginPath(); 
                    ctx.moveTo(this.x + this.width/2, this.y); // Top point
                    ctx.lineTo(this.x, this.y + this.height * 0.75); // Left wing tip
                    ctx.lineTo(this.x + this.width/2, this.y + this.height * 0.5); // Body center
                    ctx.lineTo(this.x + this.width, this.y + this.height * 0.75); // Right wing tip
                    ctx.closePath(); ctx.fill();
                } else if (this.type === 'fire_pit') {
                    ctx.fillStyle = '#A0522D'; // Base of fire pit
                    ctx.fillRect(this.x, this.y + this.height * 0.6, this.width, this.height * 0.4);
                    // Flames (animated slightly)
                    const flameHeight = this.height * 0.7;
                    const flameWidth = this.width * 0.8;
                    const flameX = this.x + this.width * 0.1;
                    const flameY = this.y + this.height * 0.1;
                    ctx.fillStyle = (this.game.animationFrame % 20 < 10) ? '#FF4500' : '#FFA500'; // Orange/Red flicker
                    ctx.beginPath();
                    ctx.moveTo(flameX, flameY + flameHeight);
                    ctx.quadraticCurveTo(flameX + flameWidth/2, flameY - Math.random()*10, flameX + flameWidth, flameY + flameHeight);
                    ctx.quadraticCurveTo(flameX + flameWidth*0.7, flameY + flameHeight*0.5, flameX + flameWidth*0.5, flameY + flameHeight);
                    ctx.quadraticCurveTo(flameX + flameWidth*0.3, flameY + flameHeight*0.5, flameX, flameY + flameHeight);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'skull_turret') {
                    // Simple skull representation
                    ctx.fillStyle = '#E0E0E0'; // Light grey for skull
                    ctx.beginPath();
                    ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000000'; // Eye sockets
                    ctx.beginPath();
                    ctx.arc(this.x + this.width * 0.3, this.y + this.height * 0.4, this.width * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(this.x + this.width * 0.7, this.y + this.height * 0.4, this.width * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'crater') { // NEW: Crater drawing
                    ctx.fillStyle = '#5B3A29'; // Dark brown for crater depression
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, this.height / 2.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#40281C'; // Even darker for the center
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.width / 2, this.y + this.height / 2, this.width / 3, this.height / 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                 } else {
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }

            onInteract(player) {
                if (this.objData.triggersPuzzle && (!this.game.player || !this.game.player.hasItem('final_artifact')) && !this.objData.opened) {
                    this.game.startPuzzle(this.objData.puzzleDetails);
                    // this.objData.opened = true; // Mark puzzle as attempted only after it's shown, not on interact if effects are playing
                    return;
                }

                if (this.objData.portalOnInteract && this.objData.toMap && !this.objData.isNowPortal) {
                    if(this.objData.interactionText) {
                        this.game.ui.showDialog(this.objData.interactionText, (this.objData.name || this.type).toUpperCase());
                        this.game.setGameState(GAME_STATE.DIALOG);
                        this.game.pendingPortal = { mapName: this.objData.toMap, toX: this.objData.toX, toY: this.objData.toY };
                        this.objData.isNowPortal = true; 
                        this.objData.text = "The passage is open."; 
                    } else {
                        this.game.changeMap(this.objData.toMap, this.objData.toX, this.objData.toY);
                    }
                    return;
                }

                if (this.objData.portal && this.objData.toMap) {
                    this.game.changeMap(this.objData.toMap, this.objData.toX, this.objData.toY);
                    return;
                }

                if ((this.type === 'chest') && this.objData.contains && !this.objData.opened) {
                    if (player.addItem(this.objData.contains)) {
                        this.game.ui.showDialog(this.objData.text || `You found a ${this.game.itemTypes[this.objData.contains].name}!`, this.type.toUpperCase());
                        this.objData.opened = true; 
                        if (this.objData.questComplete) { 
                            player.completeQuest(this.objData.questComplete);
                        }
                    } else {
                         this.game.ui.showDialog("The container is empty or you already have this item.", this.type.toUpperCase());
                    }
                     this.game.setGameState(GAME_STATE.DIALOG);
                     return;
                }
                
                // For general interactive objects (like signs, or the modified chamber exit)
                if (this.objData.text && !this.objData.opened && this.type !== 'pedestal') { 
                    this.game.ui.showDialog(this.objData.text, (this.objData.name || this.type).toUpperCase());
                    this.game.setGameState(GAME_STATE.DIALOG);
                    // Do not mark as 'opened' if it's a repeatable message (like the chamber exit)
                    // unless specifically intended. For the chamber exit, we want it to always show the message.
                }

                if (this.type === 'water_source') {
                    if (player.hydration < player.maxHydration) {
                        player.hydrate(player.maxHydration); 
                        this.game.ui.showDialog("You refill your canteen and take a long drink. You feel refreshed.", "Water Source");
                        this.game.sound.playSound('drink');
                    } else {
                        this.game.ui.showDialog("Your canteen is already full.", "Water Source");
                    }
                    this.game.setGameState(GAME_STATE.DIALOG);
                    return;
                }

                if (this.objData.questTrigger) { 
                    player.addQuest(this.objData.questTrigger);
                     this.game.ui.showDialog(this.objData.questTrigger.startText || `New Quest: ${this.objData.questTrigger.description}`, "INFO");
                     this.game.setGameState(GAME_STATE.DIALOG);
                     delete this.objData.questTrigger; // Trigger only once
                     return;
                }

                 if (this.objData.requiredItem && this.objData.questComplete) {
                    if (player.hasItem(this.objData.requiredItem)) {
                        player.completeQuest(this.objData.questComplete);
                        if(this.objData.rewardText) this.game.ui.showDialog(this.objData.rewardText, "System");
                        this.isInteractable = false; // Make non-interactable after completion
                    } else {
                        this.game.ui.showDialog(this.objData.needItemText || "You seem to be missing something...", "System");
                    }
                    this.game.setGameState(GAME_STATE.DIALOG);
                    return;
                }
            }
        }
        
        class GameMap {
            constructor(game, mapData) {
                this.game = game;
                this.name = mapData.name;
                this.background = mapData.background;
                this.objects = [];
                this.npcs = [];
                this.enemies = [];
                this.projectiles = []; // For arrows
                
                this.loadEntities(mapData);
            }

            loadEntities(mapData) {
                this.objects = [];
                this.npcs = []; 
                this.enemies = [];
                this.projectiles = [];

                (mapData.objects || []).forEach(objData => {
                    const baseObjectType = this.game.objectTypes[objData.type] || {};
                    const instanceData = JSON.parse(JSON.stringify({ ...baseObjectType, ...objData })); // Deep copy
                    this.objects.push(new InteractiveObject(this.game, instanceData.x, instanceData.y, instanceData));
                });

                (mapData.npcs || []).forEach(npcData => {
                    this.npcs.push(new NPC(this.game, npcData.x, npcData.y, npcData.name, npcData.sprite, npcData.dialog));
                });

                (mapData.enemies || []).forEach(enemyData => {
                    const baseEnemyType = {...this.game.enemyTypes[enemyData.type]}; // Shallow copy is fine here
                    this.enemies.push(new Enemy(this.game, enemyData.x, enemyData.y, {...baseEnemyType, name: enemyData.type})); // Add name for damage source
                });
            }

            addProjectile(projectile) {
                this.projectiles.push(projectile);
            }

            update() {
                if (this.game.gameState !== GAME_STATE.PLAYING) return;
                this.npcs.forEach(npc => npc.update());
                [...this.enemies].forEach(enemy => enemy.update()); // Iterate over a copy if enemies can be removed during update

                // Update skull turrets (which are InteractiveObjects)
                this.objects.forEach(obj => {
                    if (obj.type === 'skull_turret' && typeof obj.updateTurret === 'function') {
                        obj.updateTurret();
                    }
                });

                // Update projectiles
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    this.projectiles[i].update();
                    if (this.projectiles[i].lifeSpan <= 0) {
                        this.projectiles.splice(i, 1);
                    }
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.background;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Night time overlay
                if (!this.game.dayTime) {
                    ctx.fillStyle = 'rgba(0, 0, 30, 0.65)'; // Dark blueish overlay for night
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                }

                // Combine all drawable entities and sort by Y for pseudo-3D effect
                const allDrawableEntities = [...this.objects, ...this.npcs, ...this.enemies, ...this.projectiles];
                if (this.game.player) {
                    allDrawableEntities.push(this.game.player);
                }
                
                allDrawableEntities.sort((a, b) => (a.y + a.height) - (b.y + b.height));
                
                allDrawableEntities.forEach(entity => {
                    if (entity && typeof entity.draw === 'function') { // Check if entity exists and has draw method
                         entity.draw(ctx); 
                    }
                });
            }

            checkCollision(x, y, width, height) {
                // Check map boundaries
                if (x < 0 || x + width > CANVAS_WIDTH || y < 0 || y + height > CANVAS_HEIGHT) {
                    return true;
                }
                // Check collision with solid objects
                for (const obj of this.objects) {
                    if (obj.objData.solid && 
                        x < obj.x + obj.width && x + width > obj.x &&
                        y < obj.y + obj.height && y + height > obj.y) {
                        return true;
                    }
                }
                return false;
            }

            tryInteraction(checkX, checkY, player) {
                let interactionTarget = null;
                let minDistance = Infinity;

                // Check NPCs and Objects for interaction
                const checkInteraction = (entity) => {
                    if (!entity.isInteractable) return;
                    // Simple distance check to the center of the entity
                    const dist = Math.sqrt(Math.pow(entity.centerX - checkX, 2) + Math.pow(entity.centerY - checkY, 2));
                    // Allow interaction if within half the entity's average dimension + a small buffer
                    if (dist < (entity.width + entity.height) / 2 + 10 && dist < minDistance) { 
                        minDistance = dist;
                        interactionTarget = entity;
                    }
                };
                [...this.objects, ...this.npcs].forEach(checkInteraction);


                if (interactionTarget) {
                    this.game.interactionTarget = interactionTarget; // For drawing indicator
                    interactionTarget.onInteract(player);
                } else {
                    this.game.interactionTarget = null;
                }
            }
            
            removeEnemy(enemyInstance) {
                this.enemies = this.enemies.filter(e => e !== enemyInstance);
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameState = GAME_STATE.START_SCREEN;
                this.animationFrame = 0; // Global animation frame counter for effects
                
                this.sound = new SoundManager(); 
                this.ui = new UIManager(this);
                this.input = new InputHandler(this);

                this.player = null;
                this.currentMap = null;
                this.interactionTarget = null; // Object player is facing for interaction
                this.pendingPortal = null; // For dialogs that lead to portals
                this.currentPuzzle = null; 

                this.gameTime = 8 * 3600; // Start at 8:00 AM on Day 1
                this.dayTime = true;
                this.lastFrameTime = 0;

                this.defineGameData(); 

                this.ui.showStartScreen();
                this.sound.playMusic('menuTheme');
            }

            defineGameData() {
                this.objectTypes = { 
                    // Visual & Obstacle Objects
                    cactus: { width: 32, height: 48, solid: true, color: '#2D7D40' },
                    rock: { width: 32, height: 32, solid: true, color: '#7D7064' },
                    crater: { name: "Impact Crater", width: 80, height: 40, solid: false, interactive: true, text: "A strange, smooth crater. It looks recent.", color: '#5B3A29' }, // NEW
                    
                    // Interactive & Functional Objects
                    chest: { width: 32, height: 32, solid: true, interactive: true, color: '#8B4513', opened: false }, 
                    sign: { width: 32, height: 32, solid: false, interactive: true, color: '#DAA520' }, 
                    interactive_point: {width: 32, height: 32, solid: false, interactive: true, color: '#DAA520'}, 
                    petroglyph_panel: { name: "Petroglyphs", width: 48, height: 48, solid: false, interactive: true, color: '#8B4513'},
                    ancient_symbol: { name: "Ancient Symbol", width: 32, height: 32, solid: false, interactive: true, color: '#DAA520'},
                    doorway: { width: 48, height: 16, solid: false, portal: true, color: '#555555', interactive: true }, 
                    water_source: { width: 32, height: 32, solid: false, interactive: true, color: '#3377CC'},
                    
                    // Lab & Tech Objects
                    computer_terminal: { name: "Computer", width: 32, height: 32, solid: true, interactive: true, color: '#222222'},
                    lab_bench: { name: "Lab Bench", width: 96, height: 32, solid: true, interactive: false, color: '#777777'},
                    server_rack: { name: "Server Rack", width: 48, height: 128, solid: true, interactive: true, color: '#333333', text: "Humming servers... data unknown."},
                    
                    // Story & Puzzle Objects
                    secret_panel: { name: "Loose Panel", width: 32, height: 48, solid:true, interactive: true, color: '#6B5B4B'}, 
                    pedestal: { name: "Artifact Pedestal", width: 32, height: 32, solid: true, interactive: true, color: '#8888AA', opened: false, triggersPuzzle: true, 
                        puzzleDetails: {
                            question: "What are the first 5 digits of Pi?",
                            options: ["3.1415", "3.1459", "3.1419"],
                            correctAnswerIndex: 0 
                        }
                    },
                    
                    // Hohokam & Ancient Site Objects
                    hohokam_canal: { name: "Ancient Canal", width: 128, height: 32, solid: false, interactive: true, color: '#658EA9', text: "A segment of an ancient Hohokam canal. Remarkably preserved."},
                    platform_mound: { name: "Platform Mound", width: 96, height: 48, solid: true, interactive: true, color: '#B08D57', text: "This earthen mound likely held important structures."},
                    sky_hole_wall: { name: "Observatory Wall", width: 32, height: 96, solid: true, interactive: true, color: '#A08C78', text: "A precisely placed aperture in this wall seems to align with celestial events."},
                    phoenix_statue: { name: "Phoenix Statue", width: 48, height: 48, solid: true, interactive: true, color: '#FF8C00', text: "A statue of a Phoenix, symbol of rebirth. It feels warm to the touch."},
                    fire_pit: { name: "Sacred Fire", width: 48, height: 32, solid:true, interactive: true, color: '#A0522D', text: "An eternal flame flickers here." },
                    skull_turret: { name: "Guardian Skull", width: 32, height: 32, solid: true, interactive: false, color: '#E0E0E0' } // Not directly interactive by player, but updates
                };
                this.enemyTypes = {
                    scorpion: { name: 'Scorpion', width: 24, height: 24, damage: 5, speed: 0.8, health: 30, color: '#663300' },
                    snake: { name: 'Snake', width: 32, height: 16, damage: 8, speed: 1.2, health: 20, color: '#AA7722' },
                    coyote: { name: 'Coyote', width: 40, height: 24, damage: 10, speed: 1.5, health: 50, color: '#AA8855' },
                    spider: { name: 'Giant Spider', width: 32, height: 32, damage: 7, speed: 1.1, health: 40, color: '#3A3A3A', attackCooldown: 90 },
                    attacking_ghost: { name: 'Restless Spirit', width: 24, height: 32, damage: 6, speed: 1.3, health: 35, color: '#A0B0D0', isEthereal: true, aggroRange: 180 }
                };
                this.itemTypes = {
                    canteen: { name: 'Canteen', description: 'Keeps you hydrated. Refill at water sources.', useFunc: (game) => {
                        if (game.player.hydration < game.player.maxHydration) {
                            game.player.hydrate(HYDRATION_PER_DRINK);
                            game.ui.showDialog("You take a drink of water.", "Canteen");
                            game.sound.playSound('drink');
                        } else {
                             game.ui.showDialog("You're not thirsty right now.", "Canteen");
                        }
                        game.setGameState(GAME_STATE.DIALOG);
                    }},
                    compass: { name: 'Compass', description: 'Helps you navigate.' },
                    journal: { name: 'Journal', description: 'Contains research notes and quests.', useFunc: (game) => game.ui.toggleQuestLog() },
                    artifact1: { name: 'Stone Tablet', description: 'Part of an ancient artifact set.' },
                    final_artifact: { name: 'Arizona Artifact', description: 'The legendary treasure! Its power is immense.'},
                };
                 this.maps = { // Order: desert, canyon, camelback, hohokam_site, casa_grande, sky_people_shrine, white_tanks_petroglyphs, asu_lab, artifact_chamber
                    desert: { 
                        name: 'Sonoran Desert Outskirts', background: '#E2C9A1',
                        objects: [
                            { type: 'cactus', x: 100, y: 100 }, { type: 'cactus', x: 400, y: 150 }, { type: 'rock', x: 250, y: 200 }, 
                            { type: 'sign', x: 150, y: 240, text: "Caution: Desert conditions ahead!" }, { type: 'water_source', x: 50, y: 300},
                            { type: 'doorway', x: CANVAS_WIDTH - 48, y: 232, toMap: 'canyon', toX: 50, toY: 240, text: "To Canyon"}
                        ],
                        npcs: [ { name: 'Ranger Rick', x: 200, y: 300, dialog: ["Howdy, Professor! Dehydration is no joke.", "Strange lights in the sky lately..."] } ],
                        enemies: [ { type: 'scorpion', x: 300, y: 400 }, { type: 'snake', x: 450, y: 100 } ]
                    },
                    canyon: { 
                        name: 'Red Rock Canyon', background: '#BC6C25',
                        objects: [
                            { type: 'rock', x: 100, y: 100 }, { type: 'chest', x: 400, y: 200, contains: 'artifact1', text: "You found an ancient stone tablet!" },
                            { type: 'doorway', x: 0, y: 232, toMap: 'desert', toX: CANVAS_WIDTH - 70, toY: 240, text:"To Desert"},
                            { type: 'doorway', x: CANVAS_WIDTH - 48, y: 100, toMap: 'camelback', toX: 50, toY: 100, text:"To Mt."},
                            // ADDED VISUALS FOR RED ROCK CANYON
                            { type: 'crater', x: 300, y: 350, width: 100, height: 50 }, // Added crater
                            { type: 'rock', x: 150, y: 350, width: 60, height: 40, solid: true, color: '#6B4226' }, 
                            { type: 'cactus', x: 500, y: 80 },
                        ],
                        npcs: [ { name: 'Old Hermit', x: 250, y: 150, dialog: "The earth groans under the weight of secrets. Some are best left buried... or are they?"}], // Corrected dialog
                        enemies: [ { type: 'coyote', x: 350, y: 100 } ]
                    },
                    camelback: { 
                        name: 'Camelback Mountain Trail', background: '#A0B084',
                        objects: [
                            { type: 'sign', x: 50, y: 400, text: "Echo Canyon Trailhead" }, { type: 'rock', x: 150, y: 350 },
                            { type: 'interactive_point', x: 320, y: 50, text: "Scenic Overlook: A breathtaking view of Scottsdale." },
                            { type: 'doorway', x: 0, y: 100, toMap: 'canyon', toX: CANVAS_WIDTH - 70, toY: 100, text:"To Canyon"},
                            { type: 'doorway', x: CANVAS_WIDTH-48, y: 200, toMap: 'hohokam_site', toX: 50, toY: 240, text:"Ancient Path"}
                        ],
                        npcs: [ { name: 'Tired Hiker', x: 450, y: 280, dialog: ["Almost... at the top... Need water!", "Watch out for loose rocks."]} ],
                        enemies: [ { type: 'snake', x: 200, y: 150 } ]
                    },
                    hohokam_site: {
                        name: "Hohokam Settlement Ruins", background: "#D2B48C", 
                        objects: [
                            {type: "platform_mound", x: 300, y: 100, width:120, height:60}, {type: "platform_mound", x: 100, y: 350, width:80, height:40},
                            {type: "hohokam_canal", x: 50, y: 250, width:540, height:40}, 
                            // {type: "hohokam_canal", x: 400, y: 50, width:40, height:180}, // REMOVED this water feature
                            {type: "interactive_point", x:100, y:50, text: "The remains of a vast canal system..."}, {type: "rock", x:500, y:400},
                            {type: "doorway", x:0, y:232, toMap: 'camelback', toX: CANVAS_WIDTH - 70, toY: 200, text:"Back Trail"},
                            {type: "doorway", x: CANVAS_WIDTH - 48, y: 150, toMap: 'casa_grande', toX: 50, toY: 240, text:"To Great House"}
                        ],
                        npcs: [{name: "Hohokam Spirit", x: 350, y: 180, dialog: ["We followed the water... and the stars.", "Why we vanished... even the desert keeps that secret."]}],
                        enemies: [
                            {type: 'scorpion', x:450, y:350},
                            {type: 'coyote', x: 150, y: 150}, // ADDED animal
                            {type: 'snake', x: 400, y: 300}   // ADDED animal
                        ]
                    },
                    casa_grande: {
                        name: "Casa Grande Ruins", background: "#C19A6B", 
                        objects: [
                            {type: "sky_hole_wall", x: 200, y: 100, width:32, height:120},
                            {type: "sky_hole_wall", x: 400, y: 100, width:32, height:120},
                            {type: "sign", x:300, y:300, text:"The Great House - An ancient astronomical observatory."},
                            {type: "doorway", x:0, y:232, toMap: 'hohokam_site', toX: CANVAS_WIDTH - 70, toY: 150, text:"To Settlement"},
                            {type: "doorway", x: CANVAS_WIDTH - 48, y: 180, toMap: 'sky_people_shrine', toX: 50, toY: 240, text:"Spiritual Path"}
                        ],
                        npcs: [{name: "Astronomer's Ghost", x: 300, y: 200, dialog: ["The sun, moon, Venus... they all danced for us.", "These walls tracked their movements, marking time."]}],
                        enemies: [
                            {type: 'spider', x: 100, y: 350}, {type: 'spider', x: 500, y: 100},
                            {type: 'attacking_ghost', x: 320, y: 150}
                        ]
                    },
                    sky_people_shrine: {
                        name: "Sky People's Shrine", background: "#483D8B", 
                        objects: [
                            {type: "ancient_symbol", x: 150, y: 150, text: "A depiction of the Sipapu, the Hopi emergence portal."},
                            {type: "ancient_symbol", x: 450, y: 150, text: "Symbols resembling Kachinas, star spirits."},
                            {type: "fire_pit", x: CANVAS_WIDTH/2 - 24, y: 200},
                            {type: "skull_turret", x: 100, y: 300}, {type: "skull_turret", x: CANVAS_WIDTH - 132, y: 300},
                            {type: "interactive_point", x:320, y:50, text:"This place feels sacred, humming with ancient energy."},
                            {type: "doorway", x:0, y:232, toMap: 'casa_grande', toX: CANVAS_WIDTH - 70, toY: 180, text:"To Ruins"},
                            {type: "doorway", x: CANVAS_WIDTH - 48, y: 200, toMap: 'white_tanks_petroglyphs', toX: 50, toY: 240, text:"To Petroglyphs"}
                        ],
                        npcs: [{name: "Tribal Elder Spirit", x:300, y:350, dialog: ["Our ancestors came from the stars.", "They taught us to live in balance with the cosmos."]}],
                        enemies: []
                    },
                    white_tanks_petroglyphs: {
                        name: "White Tank Mountains Petroglyphs", background: "#D2691E", 
                        objects: [
                            {type: "petroglyph_panel", x:100, y:100, width:64, height:64, text:"Spirals and strange figures..."},
                            {type: "petroglyph_panel", x:400, y:250, width:64, height:64, text:"Humanoids with large heads?"},
                            {type: "rock", x:250, y:150},
                            {type: "doorway", x:0, y:232, toMap: 'sky_people_shrine', toX: CANVAS_WIDTH - 70, toY: 200, text:"To Shrine"},
                            {type: "doorway", x: CANVAS_WIDTH - 48, y: 120, toMap: 'asu_lab', toX: 50, toY: 240, text:"To ASU"},
                            // ADDED VISUALS FOR WHITE TANKS
                            { type: 'rock', x: 50, y: 200, width: 40, height: 40, solid: true, color: '#8A7967' },
                            { type: 'cactus', x: 300, y: 50 },
                            { type: 'interactive_point', x: 200, y: 350, text: "The air is unusually still here. The rocks seem to watch."},
                        ],
                        npcs: [{name: "Petroglyph Researcher", x:500, y:100, dialog: ["These symbols are thousands of years old.", "Some say they depict star charts... or even visitors."]}],
                        enemies: [{type: 'coyote', x:150, y:350}]
                    },
                    asu_lab: { 
                        name: 'ASU Engineering Lab', background: '#4A4A52',
                        objects: [
                            { type: 'computer_terminal', x: 100, y: 100, text: "System Offline. Project PHOENIX data corrupted." },
                            { type: 'lab_bench', x: 200, y: 150}, { type: 'server_rack', x: 500, y: 80},
                            { type: 'phoenix_statue', x: 300, y: 50},
                            { type: 'secret_panel', x: 300, y: 400, 
                                portalOnInteract: true, toMap: 'artifact_chamber', toX: CANVAS_WIDTH/2 - 16, toY: CANVAS_HEIGHT - 80, 
                                interactionText: "You push the Phoenix statue. A panel slides open!" },
                            { type: 'doorway', x: 0, y: 232, toMap: 'white_tanks_petroglyphs', toX: CANVAS_WIDTH - 70, toY: 120, text:"Exit"}
                        ],
                        npcs: [ {name: "Grad Student", x: 400, y: 300, dialog: ["Working on my thesis... don't mind the mess.", "Heard whispers of a hidden chamber related to Project Phoenix."]}],
                        enemies: [] 
                    },
                    artifact_chamber: {
                        name: 'Hidden Artifact Chamber', background: '#301020', // Darker, more ominous
                        objects: [
                            { type: 'pedestal', x: CANVAS_WIDTH/2 - 16, y: CANVAS_HEIGHT/2 - 16 }, 
                            // MODIFIED "EXIT"
                            { 
                                type: 'interactive_point', 
                                x: CANVAS_WIDTH/2 - 24, y: CANVAS_HEIGHT - 48, 
                                width: 48, height: 16, // Match typical doorway size
                                solid: true, // Player cannot pass
                                interactive: true, 
                                color: '#3E2731', // Dark, sealed-off color
                                text: "You never had a choice. You just thought you did. Hope wasn't invited." // Creepy message
                            }
                        ],
                        npcs: [], enemies: []
                    }
                };
            }
            
            setGameState(newState) {
                const oldState = this.gameState;
                this.gameState = newState;
                
                // Hide all screens by default, then show the relevant one
                if (newState !== GAME_STATE.START_SCREEN) this.ui.hideStartScreen();
                if (newState !== GAME_STATE.PAUSED) this.ui.hidePauseScreen();
                if (newState !== GAME_STATE.GAME_OVER) this.ui.hideGameOverScreen();
                if (newState !== GAME_STATE.PUZZLE) this.ui.hidePuzzle();
                if (newState !== GAME_STATE.WIN) this.ui.hideWinScreen();
                
                if (newState !== GAME_STATE.DIALOG) { // Hide dialog unless explicitly in dialog state
                    this.ui.hideDialog();
                }

                switch(newState) {
                    case GAME_STATE.START_SCREEN: 
                        this.ui.showStartScreen(); this.sound.playMusic('menuTheme'); break;
                    case GAME_STATE.PLAYING: 
                        if (oldState === GAME_STATE.PAUSED || oldState === GAME_STATE.PUZZLE) this.sound.resumeCurrentMusic();
                        break; 
                    case GAME_STATE.PAUSED: 
                        this.ui.showPauseScreen(); this.sound.pauseCurrentMusic(); break;
                    case GAME_STATE.DIALOG: break; // Dialog is shown by interaction logic
                    case GAME_STATE.PUZZLE: 
                        this.sound.pauseCurrentMusic(); 
                        this.ui.showPuzzle(this.currentPuzzle.question, this.currentPuzzle.options); 
                        break;
                    case GAME_STATE.WIN:
                        this.sound.stopMusic(); this.sound.playSound('winGame');
                        this.ui.showWinScreen("You solved the puzzle and claim the Arizona Artifact!");
                        break;
                    case GAME_STATE.GAME_OVER: 
                        this.sound.stopMusic(); this.sound.playSound('gameOver'); 
                        // Game over screen is shown by the gameOver method itself
                        break;
                }
            }

            startGame(isRestart = false) {
                this.ui.hideStartScreen(); 
                this.ui.showLoading();
                
                setTimeout(() => {
                    this.player = new Player(this, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                    this.gameTime = 8 * 3600; // Reset game time
                    this.defineGameData(); // Re-initialize map data to reset chests, etc.
                    this.currentMap = null; // Ensure map is freshly loaded
                    this.changeMap('desert', this.player.x, this.player.y); 
                    
                    this.ui.updateHealth(this.player.health, this.player.maxHealth);
                    this.ui.updateHydration(this.player.hydration, this.player.maxHydration);
                    this.ui.updateInventoryDisplay(this.player.inventory, this.itemTypes);
                    this.ui.updateQuestLog(this.player.quests);
                    
                    this.setGameState(GAME_STATE.PLAYING); 
                    this.ui.hideLoading();
                    if (!isRestart || this.lastFrameTime === 0) { // Start game loop if not already running
                         this.gameLoop(0); 
                    }
                }, 500); // Simulate loading time
            }
            
            goToMainMenu() {
                this.sound.stopMusic(); // Stop any current game music
                this.setGameState(GAME_STATE.START_SCREEN); // Transition to start screen
            }

            changeMap(mapName, playerX, playerY) {
                const isInitialLoad = !this.currentMap; // Check if this is the very first map load
                this.sound.stopMusic(); // Stop current map's music
                if (!isInitialLoad) this.sound.playSound('nextScenario'); // Play transition sound

                if (this.maps[mapName]) {
                    const mapData = this.maps[mapName];
                    // IMPORTANT: Create a deep copy of mapData to ensure objects (like chests) reset their state if the player revisits a map after a game restart.
                    // For a persistent world within a single playthrough, a shallow copy or direct use might be intended, but for full resets on new games, deep copy is safer.
                    const freshMapData = JSON.parse(JSON.stringify(mapData)); 
                    this.currentMap = new GameMap(this, freshMapData); // Load map with fresh data
                    
                    if (this.player) { this.player.x = playerX; this.player.y = playerY; }
                    this.ui.updateMapName(this.currentMap.name); 

                    // Delay music start to allow transition sound to play
                    const musicDelay = isInitialLoad ? 0 : (this.sound.sounds.nextScenario.duration && isFinite(this.sound.sounds.nextScenario.duration) ? this.sound.sounds.nextScenario.duration * 1000 : 200);

                    setTimeout(() => {
                        // Check if still in a valid game state and on the correct map before playing music
                        if ((this.gameState !== GAME_STATE.PLAYING && this.gameState !== GAME_STATE.DIALOG) || !this.currentMap || this.currentMap.name !== mapData.name) return; 

                        // Play map-specific music
                        if (mapName === 'desert') {
                            if (isInitialLoad) { // Special handling for initial game start sound
                                this.sound.playSound('gameStart');
                                const gameStartDuration = this.sound.sounds.gameStart.duration;
                                setTimeout(() => {
                                    if (this.gameState === GAME_STATE.PLAYING && this.currentMap && this.currentMap.name === 'Sonoran Desert Outskirts') {
                                        this.sound.playMusic('firstScenarioTheme', true);
                                    }
                                }, gameStartDuration && isFinite(gameStartDuration) ? gameStartDuration * 1000 : 500);
                            } else this.sound.playMusic('firstScenarioTheme', true);
                        } else if (mapName === 'canyon') this.sound.playMusic('secondScenarioTheme', true);
                        else if (mapName === 'camelback') this.sound.playMusic('thirdScenarioTheme', true);
                        else if (mapName === 'hohokam_site') this.sound.playMusic('hohokamTheme', true);
                        else if (mapName === 'casa_grande') this.sound.playMusic('casaGrandeTheme', true);
                        else if (mapName === 'sky_people_shrine') this.sound.playMusic('skyPeopleTheme', true);
                        else if (mapName === 'white_tanks_petroglyphs') this.sound.playMusic('whiteTanksTheme', true);
                        else if (mapName === 'asu_lab') this.sound.playMusic('asuLabTheme', true);
                        else if (mapName === 'artifact_chamber') this.sound.playMusic('chamberTheme', true);
                    }, musicDelay);
                } else console.error(`Map ${mapName} not found!`);
            }

            startPuzzle(puzzleDetails) {
                this.currentPuzzle = puzzleDetails; // Store the puzzle details
                this.sound.playSound('thunder');
                
                // Screen Shake Effect
                const gameContainer = document.getElementById('gameContainer');
                let shakes = 0;
                const shakeDuration = 500; // Total duration of shake in ms
                const shakeIntervalTime = 50; // Interval time for each shake movement
                const numShakes = shakeDuration / shakeIntervalTime;

                const interval = setInterval(() => {
                    const x = (Math.random() - 0.5) * 10; // Max 5px shake horizontally
                    const y = (Math.random() - 0.5) * 10; // Max 5px shake vertically
                    gameContainer.style.transform = `translate(${x}px, ${y}px)`;
                    shakes++;
                    if (shakes >= numShakes) {
                        clearInterval(interval);
                        gameContainer.style.transform = 'translate(0,0)';
                        // Mark pedestal as "opened" to prevent re-triggering puzzle immediately if player closes dialog
                        const pedestal = this.currentMap.objects.find(obj => obj.objData.triggersPuzzle);
                        if(pedestal) pedestal.objData.opened = true;
                        
                        this.setGameState(GAME_STATE.PUZZLE); // Show puzzle UI AFTER effects
                    }
                }, shakeIntervalTime);
            }


            handlePuzzleAnswer(answerIndex) {
                if (!this.currentPuzzle) return;
                this.ui.hidePuzzle();

                if (answerIndex === this.currentPuzzle.correctAnswerIndex) {
                    this.sound.playSound('puzzleCorrect');
                    this.player.addItem('final_artifact');
                    this.player.completeQuest('main_artifact'); 
                    setTimeout(() => { // Slight delay before win screen
                        this.setGameState(GAME_STATE.WIN);
                    }, 500); 
                } else {
                    this.sound.playSound('puzzleIncorrect');
                    this.gameOver("Incorrect. The artifact's secrets remain elusive.");
                }
                this.currentPuzzle = null; // Clear current puzzle
            }


            gameLoop(timestamp) {
                this.animationFrame++; // Increment global animation frame
                const deltaTime = (timestamp - this.lastFrameTime) / 1000; // Time since last frame in seconds
                this.lastFrameTime = timestamp;

                if (this.gameState === GAME_STATE.PLAYING) {
                    this.update(deltaTime);
                }
                this.draw();
                
                requestAnimationFrame((ts) => this.gameLoop(ts)); // Continue the loop
            }

            update(deltaTime) {
                if (!this.player || !this.currentMap) return;

                this.player.update();
                this.currentMap.update(); // This will update enemies, skull turrets, and projectiles
                this.interactionTarget = null; // Reset interaction target each frame

                // Update game time and day/night cycle
                this.gameTime += deltaTime * GAME_TIME_MULTIPLIER;
                const currentHour = Math.floor((this.gameTime % (24 * 3600)) / 3600);
                this.dayTime = currentHour >= 6 && currentHour < 20; // Day from 6 AM to 8 PM
                this.ui.updateClock(this.gameTime);

                // Check for potential interaction targets in front of the player
                let checkX = this.player.x + this.player.width / 2;
                let checkY = this.player.y + this.player.height / 2;
                const checkRange = 20; // How far in front to check
                 switch (this.player.direction) {
                    case 'up': checkY -= this.player.height / 2 + checkRange / 2; break;
                    case 'down': checkY += this.player.height / 2 + checkRange / 2; break;
                    case 'left': checkX -= this.player.width / 2 + checkRange / 2; break;
                    case 'right': checkX += this.player.width / 2 + checkRange / 2; break;
                }
                const potentialTargets = [...this.currentMap.objects, ...this.currentMap.npcs];
                for (const entity of potentialTargets) {
                    if (entity.isInteractable && 
                        Math.abs(entity.centerX - checkX) < (entity.width/2 + 10) && // Check X overlap
                        Math.abs(entity.centerY - checkY) < (entity.height/2 + 10)) { // Check Y overlap
                        this.interactionTarget = entity;
                        break; // Interact with the first one found
                    }
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); // Clear canvas
                if (this.gameState === GAME_STATE.PLAYING || this.gameState === GAME_STATE.DIALOG || this.gameState === GAME_STATE.PAUSED) {
                    if (this.currentMap && this.player) { // Ensure map and player exist
                        this.currentMap.draw(this.ctx);
                        // Player is drawn as part of currentMap's sorted entities
                    }
                    // Draw interaction indicator if a target is present and game is playing
                    if (this.interactionTarget && this.gameState === GAME_STATE.PLAYING) {
                        this.ui.drawInteractionIndicator(this.interactionTarget.centerX, this.interactionTarget.y);
                    }
                }
                // Other game states (start, game over, win) are handled by HTML elements overlaying the canvas
            }
            
            handleKeyUp(key) {
                if (this.gameState === GAME_STATE.PLAYING) {
                    if (key === 'e' || key === ' ') this.player.interact();
                    else if (key === 'p') this.togglePause();
                    else if (key === 'i') { // Show inventory as dialog
                        this.ui.showDialog("Inventory: " + this.player.inventory.map(itemKey => this.itemTypes[itemKey].name).join(', '), "System");
                        this.setGameState(GAME_STATE.DIALOG); 
                    } else if (key === 'q') this.ui.toggleQuestLog();
                } else if (this.gameState === GAME_STATE.DIALOG) {
                    if (key === 'e' || key === ' ' || key === 'enter') { // Close dialog
                        this.ui.hideDialog(); 
                        if (this.pendingPortal) { // If dialog was for a portal, change map
                            this.changeMap(this.pendingPortal.mapName, this.pendingPortal.toX, this.pendingPortal.toY);
                            this.pendingPortal = null; // Clear pending portal
                        } else this.setGameState(GAME_STATE.PLAYING); // Return to playing state
                    }
                } else if (this.gameState === GAME_STATE.PAUSED) {
                     if (key === 'p') this.togglePause(); // Unpause
                } 
                // No key handling needed for START_SCREEN, GAME_OVER, WIN, PUZZLE as they use UI buttons
            }

            togglePause() {
                if (this.gameState === GAME_STATE.PLAYING) this.setGameState(GAME_STATE.PAUSED);
                else if (this.gameState === GAME_STATE.PAUSED) this.setGameState(GAME_STATE.PLAYING);
            }

            useItem(itemKey) {
                if (this.gameState !== GAME_STATE.PLAYING && this.gameState !== GAME_STATE.DIALOG) return; // Can use items while playing or in dialog
                const item = this.itemTypes[itemKey];
                if (item && item.useFunc) item.useFunc(this); // Call item's use function
                else if (item) { // If no useFunc, just show description
                    this.ui.showDialog(`${item.name}: ${item.description}`, "Item");
                    this.setGameState(GAME_STATE.DIALOG);
                }
            }

            saveGame() {
                if (!this.player || !this.currentMap) {
                    console.warn("Cannot save: game not fully initialized.");
                    this.ui.showDialog("Cannot save game state yet.", "System"); return;
                }
                // Create a savable representation of map objects' states (e.g., opened chests)
                const savableObjects = this.currentMap.objects.map(obj => ({ 
                    type: obj.type, x: obj.x, y: obj.y, 
                    opened: obj.objData.opened, isNowPortal: obj.objData.isNowPortal 
                    // Add any other properties that need to be saved per object
                }));
                const saveData = {
                    player: {
                        x: this.player.x, y: this.player.y, health: this.player.health, hydration: this.player.hydration,
                        inventory: this.player.inventory, quests: this.player.quests, direction: this.player.direction,
                    },
                    currentMapName: this.currentMap.name, gameTime: this.gameTime, mapObjectsState: savableObjects 
                };
                try {
                    localStorage.setItem('desertChroniclesSave', JSON.stringify(saveData));
                    this.ui.showSaveNotification();
                    if(this.gameState === GAME_STATE.PAUSED) this.ui.showDialog("Game Saved!", "System"); // Show dialog if paused
                } catch (e) {
                    console.error('Error saving game:', e);
                     if(this.gameState === GAME_STATE.PAUSED) this.ui.showDialog("Error saving game.", "System");
                }
            }

            loadGame(fromStartScreen = false) {
                if (fromStartScreen) { this.ui.hideStartScreen(); this.ui.showLoading(); }
                try {
                    const savedDataJSON = localStorage.getItem('desertChroniclesSave');
                    if (!savedDataJSON) {
                        if (fromStartScreen) {
                            this.ui.hideLoading(); this.ui.showStartScreen(); 
                            alert("No save data found!"); this.sound.playMusic('menuTheme'); 
                        } return false;
                    }
                    const saveData = JSON.parse(savedDataJSON);

                    // Initialize player if not already (e.g., if loading from a running game, player might exist)
                    if (!this.player) this.player = new Player(this, saveData.player.x, saveData.player.y);
                    else { this.player.x = saveData.player.x; this.player.y = saveData.player.y; }

                    // Restore player state
                    this.player.health = saveData.player.health; this.player.hydration = saveData.player.hydration;
                    this.player.inventory = saveData.player.inventory; 
                    this.player.quests = saveData.player.quests || [{id: "main_artifact", description: "Find the Arizona Artifact.", completed: false}]; // Default quests if not in save
                    this.player.direction = saveData.player.direction; this.gameTime = saveData.gameTime;
                    
                    this.currentMap = null; // Ensure map is reloaded
                    this.changeMap(saveData.currentMapName, this.player.x, this.player.y);
                    
                    // Restore map object states
                    if (saveData.mapObjectsState && this.currentMap) {
                        this.currentMap.objects.forEach(gameObj => {
                            const savedObj = saveData.mapObjectsState.find(s => s.x === gameObj.x && s.y === gameObj.y && s.type === gameObj.type);
                            if (savedObj) {
                                if (savedObj.opened !== undefined) gameObj.objData.opened = savedObj.opened;
                                if (savedObj.isNowPortal !== undefined) gameObj.objData.isNowPortal = savedObj.isNowPortal;
                                // Restore other saved properties here
                            }
                        });
                    }
                    // Update UI
                    this.ui.updateHealth(this.player.health, this.player.maxHealth);
                    this.ui.updateHydration(this.player.hydration, this.player.maxHydration);
                    this.ui.updateInventoryDisplay(this.player.inventory, this.itemTypes);
                    this.ui.updateQuestLog(this.player.quests);
                    
                    this.setGameState(GAME_STATE.PLAYING);
                    if (fromStartScreen) {
                        this.ui.hideLoading();
                        if (this.lastFrameTime === 0) this.gameLoop(0); // Start game loop if not already running
                    } return true;
                } catch (e) {
                    console.error('Error loading game:', e);
                    if (fromStartScreen) {
                        this.ui.hideLoading(); this.ui.showStartScreen(); 
                        alert("Error loading save data. It might be corrupted."); this.sound.playMusic('menuTheme'); 
                    } return false;
                }
            }
            
            gameOver(message) {
                this.setGameState(GAME_STATE.GAME_OVER); 
                this.ui.showGameOverScreen(message); // Display game over message
            }
        }

        // --- Initialize Game ---
        document.addEventListener('DOMContentLoaded', () => {
            const game = new Game();
        });

    </script>
</body>
<div id="footer">
  <a href="https://kevincasas-dev.github.io/" target="_blank" rel="noopener noreferrer">
    &copy; 2025 Kevin Casas. All rights reserved.
  </a>
</div>
</html>
